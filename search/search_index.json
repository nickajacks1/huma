{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Huma","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A modern, simple, fast &amp; flexible micro framework for building HTTP REST/RPC APIs in Golang backed by OpenAPI 3 and JSON Schema. Pronounced IPA: /'hju\u02d0m\u0251/.</p>"},{"location":"#goals","title":"Goals","text":"<p>The goals of this project are to provide:</p> <ul> <li>A modern REST or HTTP RPC API backend framework for Go developers<ul> <li>Described by OpenAPI 3.1 &amp; JSON Schema</li> </ul> </li> <li>Incremental adoption for teams with existing services<ul> <li>Bring your own router, middleware, and logging/metrics</li> <li>Extensible OpenAPI &amp; JSON Schema layer to document existing routes</li> </ul> </li> <li>Guard rails to prevent common mistakes</li> <li>Documentation that can't get out of date</li> <li>High-quality generated developer tooling</li> </ul>"},{"location":"#starting-points","title":"Starting Points","text":"<ul> <li> Why Huma        What makes Huma different and why should you use it for your next project?  Learn more </li> </ul> <ul> <li> Tutorial in 5 Minutes      Install <code>huma</code> and have a working API in about five minutes.  Get started </li> </ul> <ul> <li> How To Guides      Learn how to solve specific real-world problems with Huma.  Solve problems </li> </ul> <ul> <li> Features &amp; Reference      Learn about all of Huma's features &amp; how to use them.  Feature docs  Go reference </li> </ul>"},{"location":"features/","title":"Features","text":"<p>Huma is a modern, simple, fast &amp; flexible micro framework for building HTTP REST/RPC APIs in Golang backed by OpenAPI 3 and JSON Schema. Pronounced IPA: /'hju\u02d0m\u0251/. The goals of this project are to provide:</p> <ul> <li>A modern REST or HTTP RPC API backend framework for Go developers<ul> <li>Described by OpenAPI 3.1 &amp; JSON Schema</li> </ul> </li> <li>Incremental adoption for teams with existing services<ul> <li>Bring your own router, middleware, and logging/metrics</li> <li>Extensible OpenAPI &amp; JSON Schema layer to document existing routes</li> </ul> </li> <li>Guard rails to prevent common mistakes</li> <li>Documentation that can't get out of date</li> <li>High-quality generated developer tooling</li> </ul> <p>Features include:</p> <ul> <li>Declarative interface on top of your router of choice:<ul> <li>Operation &amp; model documentation</li> <li>Request params (path, query, or header)</li> <li>Request body</li> <li>Responses (including errors)</li> <li>Response headers</li> </ul> </li> <li>JSON Errors using RFC7807 and <code>application/problem+json</code> by default (but can be changed)</li> <li>Per-operation request size limits with sane defaults</li> <li>Content negotiation between server and client<ul> <li>Support for JSON (RFC 8259) and CBOR (RFC 7049) content types via the <code>Accept</code> header with the default config.</li> </ul> </li> <li>Conditional requests support, e.g. <code>If-Match</code> or <code>If-Unmodified-Since</code> header utilities.</li> <li>Optional automatic generation of <code>PATCH</code> operations that support:<ul> <li>RFC 7386 JSON Merge Patch</li> <li>RFC 6902 JSON Patch</li> <li>Shorthand patches</li> </ul> </li> <li>Annotated Go types for input and output models<ul> <li>Generates JSON Schema from Go types</li> <li>Static typing for path/query/header params, bodies, response headers, etc.</li> <li>Automatic input model validation &amp; error handling</li> </ul> </li> <li>Documentation generation using Stoplight Elements</li> <li>Optional CLI built-in, configured via arguments or environment variables<ul> <li>Set via e.g. <code>-p 8000</code>, <code>--port=8000</code>, or <code>SERVICE_PORT=8000</code></li> <li>Startup actions &amp; graceful shutdown built-in</li> </ul> </li> <li>Generates OpenAPI for access to a rich ecosystem of tools<ul> <li>Mocks with API Sprout or Prism</li> <li>SDKs with OpenAPI Generator or oapi-codegen</li> <li>CLI with Restish</li> <li>And plenty more</li> </ul> </li> <li>Generates JSON Schema for each resource using optional <code>describedby</code> link relation headers as well as optional <code>$schema</code> properties in returned objects that integrate into editors for validation &amp; completion.</li> </ul> <p>Mascot</p> <p>Hi there! I'm the happy Huma whale here to provide help. You'll see me leave helpful tips throughout the docs.</p> <p>Official Go package documentation can always be found at https://pkg.go.dev/github.com/danielgtaylor/huma/v2. Read on for an introduction to the various features available in Huma.</p>"},{"location":"features/auto-patch/","title":"Auto Patch","text":""},{"location":"features/auto-patch/#auto-patch_1","title":"Auto Patch","text":"<p>If a <code>GET</code> and a <code>PUT</code> exist for the same resource, but no <code>PATCH</code> exists at server start up, then a <code>PATCH</code> operation can be generated for you to make editing more convenient for clients. You can opt-in to this behavior with the <code>autopatch</code> package:</p> <pre><code>import \"github.com/danielgtaylor/huma/autopatch\"\n\n// ...\n\n// Later in the code *after* registering operations...\nautopatch.AutoPatch(api)\n</code></pre> <p>If the <code>GET</code> returns an <code>ETag</code> or <code>Last-Modified</code> header, then these will be used to make conditional requests on the <code>PUT</code> operation to prevent distributed write conflicts that might otherwise overwrite someone else's changes.</p> <p>The following formats are supported out of the box, selected via the <code>Content-Type</code> header:</p> <ul> <li>JSON Merge Patch <code>application/merge-patch+json</code></li> <li>Shorthand Merge Patch <code>application/merge-patch+shorthand</code></li> <li>JSON Patch <code>application/json-patch+json</code></li> </ul> <p>Merge on Steroids</p> <p>You can think of the Shorthand Merge Patch as an extension to the JSON merge patch with support for field paths, arrays, and a few other features. Patches like this are possible, appending an item to an array (creating it if needed):</p> <pre><code>{\n\tfoo.bar[]: \"baz\",\n}\n</code></pre> <p>If the <code>PATCH</code> request has no <code>Content-Type</code> header, or uses <code>application/json</code> or a variant thereof, then JSON Merge Patch is assumed.</p>"},{"location":"features/auto-patch/#disabling-auto-patch","title":"Disabling Auto Patch","text":"<p>The auto patch feature can be disabled per resource by setting metadata on an operation:</p> code.go<pre><code>// Register an operation that won't get a PATCH generated.\nhuma.Register(api, huma.Operation{\n\tOperationID: \"get-greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSummary:     \"Get a greeting\",\n\tMetadata: map[string]interface{}{\n\t\t\"autopatch\": false,\n\t},\n}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// ...\n})\n</code></pre>"},{"location":"features/auto-patch/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>autopatch</code> package</li> </ul> </li> <li>External Links<ul> <li>HTTP PATCH Method</li> <li>RFC7386 JSON Merge Patch</li> <li>Shorthand Merge Patch</li> <li>RFC6902 JSON Patch</li> </ul> </li> </ul>"},{"location":"features/bring-your-own-router/","title":"BYOR (Bring Your Own Router)","text":""},{"location":"features/bring-your-own-router/#byor-bring-your-own-router_1","title":"BYOR (Bring Your Own Router)","text":"<p>Huma is designed to be router-agnostic to enable incremental adoption in existing and new services across a large number of organizations. This means you can use any router you want, or even write your own. The only requirement is an implementation of a small <code>huma.Adapter</code> interface. This is how Huma integrates with your router.</p> <p>Adapters are in the <code>adapters</code> directory and named after the router they support. Many common routers are supported out of the box (in alphabetical order):</p> <ul> <li>BunRouter via <code>humabunrouter</code></li> <li>chi via <code>humachi</code></li> <li>gin via <code>humagin</code></li> <li>Go 1.22+ <code>http.ServeMux</code> via <code>humago</code> (experimental, requires <code>go 1.22</code> in <code>go.mod</code>)</li> <li>gorilla/mux via <code>humamux</code></li> <li>httprouter via <code>humahttprouter</code></li> <li>Fiber via <code>humafiber</code></li> </ul> <p>New Adapters</p> <p>Writing your own adapter is quick and simple, and PRs are accepted for additional adapters to be built-in.</p>"},{"location":"features/bring-your-own-router/#chi-example","title":"Chi Example","text":"<p>Adapters are instantiated by wrapping your router and providing a Huma configuration object which describes the API. Here is a simple example using Chi:</p> main.go<pre><code>import (\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Create your router.\nrouter := chi.NewMux()\n\n// Wrap the router with Huma to create an API instance.\napi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n// Register your operations with the API.\n// ...\n\n// Start the server!\nhttp.ListenAndServe(\":8888\", r)\n</code></pre> <p>For existing services using Chi v4, you can use <code>humachi.NewV4</code> instead.</p>"},{"location":"features/bring-your-own-router/#dive-deeper","title":"Dive Deeper","text":"<p>The adapter converts a router-specific request context like <code>http.Request</code> or <code>fiber.Ctx</code> into the router-agnostic <code>huma.Context</code>, which is then used to call your operation's handler function.</p> <pre><code>graph LR\n\tRequest([Request])\n\tOperationHandler[Operation Handler]\n\n\tRequest --&gt; Router\n\tRouter --&gt;|http.Request\\nfiber.Ctx\\netc| huma.Adapter\n\tsubgraph huma.API\n\t\thuma.Adapter --&gt;|huma.Context| OperationHandler\n\tend</code></pre> <ul> <li>Features<ul> <li>Registering operations</li> </ul> </li> <li>Reference<ul> <li><code>huma.Context</code> a router-agnostic request/response context</li> <li><code>huma.Adapter</code> the router-agnostic adapter interface</li> <li><code>huma.API</code> the API instance</li> <li><code>huma.NewAPI</code> creates an API instance (called by adapters)</li> <li><code>huma.Register</code> registers new operations</li> </ul> </li> </ul>"},{"location":"features/cli-auto-config/","title":"CLI AutoConfig","text":"<p>Huma includes built-in support for an OpenAPI 3 extension that enables CLI auto-configuration. This allows tools like Restish to automatically configure themselves to talk to your API with the correct endpoints, authentication mechanism, etc without the user needing to know anything about your API.</p> <pre><code>o := api.OpenAPI()\no.Components.SecuritySchemes[\"my-scheme\"] = &amp;huma.SecurityScheme{\n\tType: \"oauth2\",\n\t// ... security scheme definition ...\n}\no.Extensions[\"x-cli-autoconfig\"] = huma.AutoConfig{\n\tSecurity: \"my-scheme\",\n\tParams: map[string]string{\n\t\t\"client_id\": \"abc123\",\n\t\t\"authorize_url\": \"https://example.tld/authorize\",\n\t\t\"token_url\": \"https://example.tld/token\",\n\t\t\"scopes\": \"read,write\",\n\t}\n}\n</code></pre> <p>See the CLI AutoConfiguration documentation for more info, including how to ask the user for custom parameters.</p>"},{"location":"features/cli/","title":"Service CLI","text":""},{"location":"features/cli/#service-cli_1","title":"Service CLI","text":"<p>Huma ships with a built-in lightweight utility to wrap your service with a CLI, enabling you to run it with different arguments and easily write custom commands to do things like print out the OpenAPI or run on-demand database migrations.</p> <p>The CLI options use a similar strategy to input &amp; output structs, enabling you to use the same pattern for validation and documentation of command line arguments. It uses Cobra under the hood, enabling custom commands and including automatic environment variable binding and more.</p> main.go<pre><code>// First, define your input options.\ntype Options struct {\n\tDebug bool   `doc:\"Enable debug logging\"`\n\tHost  string `doc:\"Hostname to listen on.\"`\n\tPort  int    `doc:\"Port to listen on.\" short:\"p\" default:\"8888\"`\n}\n\nfunc main() {\n\t// Then, create the CLI.\n\tcli := huma.NewCLI(func(hooks huma.Hooks, opts *Options) {\n\t\tfmt.Printf(\"I was run with debug:%v host:%v port%v\\n\",\n\t\t\topts.Debug, opts.Host, opts.Port)\n\t})\n\n\t// Run the thing!\n\tcli.Run()\n}\n</code></pre> <p>You can then run the CLI and see the results:</p> Terminal<pre><code>// Run with defaults\n$ go run main.go\nI was run with debug:false host: port:8888\n\n// Run with options\n$ go run main.go --debug=true --host=localhost --port=8000\nI was run with debug:true host:localhost port:8000\n</code></pre> <p>To do useful work, you will want to register a handler for the default start command and optionally a way to gracefully shutdown the server:</p> main.go<pre><code>cli := huma.NewCLI(func(hooks huma.Hooks, opts *Options) {\n\t// Set up the router and API\n\t// ...\n\n\t// Create the HTTP server.\n\tserver := http.Server{\n\t\tAddr:    fmt.Sprintf(\":%d\", options.Port),\n\t\tHandler: router,\n\t}\n\n\thooks.OnStart(func() {\n\t\t// Start your server here\n\t\tserver.ListenAndServe()\n\t})\n\n\thooks.OnStop(func() {\n\t\t// Gracefully shutdown your server here\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\tserver.Shutdown(ctx)\n\t})\n})\n</code></pre> <p>Naming</p> <p>Option fields are automatically converted to <code>--kebab-casing</code> for use on the command line. If you want to use a different name, use the <code>name</code> struct tag to override the default behavior!</p>"},{"location":"features/cli/#passing-options","title":"Passing Options","text":"<p>Options can be passed explicitly as command-line arguments to the service or they can be provided by environment variables prefixed with <code>SERVICE_</code>. For example, to run the service on port 8000:</p> <pre><code># Example passing command-line args\n$ go run main.go --port=8000\n\n# Short arguments are also supported\n$ go run main.go -p 8000\n\n# Example passing by environment variables\n$ SERVICE_PORT=8000 go run main.go\n</code></pre> <p>Precedence</p> <p>If both environment variable and command-line arguments are present, then command-line arguments take priority.</p>"},{"location":"features/cli/#custom-options","title":"Custom Options","text":"<p>Custom options are defined by adding to your options struct. The following types are supported:</p> Type Example Inputs <code>bool</code> <code>true</code>, <code>false</code> <code>int</code> / <code>int64</code> <code>1234</code>, <code>5</code>, <code>-1</code> <code>string</code> <code>prod</code>, <code>http://api.example.tld/</code> <p>The following struct tags are available:</p> Tag Description Example <code>default</code> Default value (parsed automatically) <code>default:\"123\"</code> <code>doc</code> Describe the option <code>doc:\"Who to greet\"</code> <code>name</code> Override the name of the option <code>name:\"my-option-name\"</code> <code>short</code> Single letter short name for the option <code>short:\"p\"</code> for <code>-p</code> <p>Here is an example of how to use them:</p> main.go<pre><code>type Options struct {\n\tDebug bool   `doc:\"Enable debug logging\"`\n\tHost  string `doc:\"Hostname to listen on.\"`\n\tPort  int    `doc:\"Port to listen on.\" short:\"p\" default:\"8888\"`\n}\n</code></pre>"},{"location":"features/cli/#custom-commands","title":"Custom Commands","text":"<p>You can access the root <code>cobra.Command</code> via <code>cli.Root()</code> and add new custom commands via <code>cli.Root().AddCommand(...)</code>. For example, to have a command print out the generated OpenAPI:</p> main.go<pre><code>var api huma.API\n\n// ... set up the CLI, create the API wrapping the router ...\n\ncli.Root().AddCommand(&amp;cobra.Command{\n\tUse:   \"openapi\",\n\tShort: \"Print the OpenAPI spec\",\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tb, _ := yaml.Marshal(api.OpenAPI())\n\t\tfmt.Println(string(b))\n\t},\n})\n</code></pre> <p>Now you can run your service and use the new command: <code>go run . openapi</code>. Notice that it never starts the server; it just runs your command handler code. Some ideas for custom commands:</p> <ul> <li>Print the OpenAPI spec</li> <li>Print JSON Schemas</li> <li>Run database migrations</li> <li>Run customer scenario tests</li> <li>Bundle common actions into a single utility command, like adding a new user</li> </ul>"},{"location":"features/cli/#custom-commands-with-options","title":"Custom Commands with Options","text":"<p>If you want to access your custom options struct with custom commands, use the <code>huma.WithOptions(func(cmd *cobra.Command, args []string, options *YourOptions)) func(cmd *cobra.Command, args []string)</code> utitity function. It ensures the options are parsed and available before running your command.</p> <p>More Customization</p> <p>You can also overwite <code>cli.Root().Run</code> to completely customize how you run the server. Or just ditch the <code>cli</code> package altogether!</p>"},{"location":"features/cli/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Service Configuration Tutorial includes a working CLI example</li> </ul> </li> <li>How-To<ul> <li>Graceful Shutdown on service stop</li> </ul> </li> <li>Reference<ul> <li><code>huma.CLI</code> the CLI instance</li> <li><code>huma.NewCLI</code> creates a new CLI instance</li> <li><code>huma.Hooks</code> for startup / shutdown</li> <li><code>huma.WithOptions</code> wraps a command with options parsing</li> <li><code>huma.API</code> the API instance</li> </ul> </li> <li>External Links<ul> <li>Cobra CLI library</li> </ul> </li> </ul>"},{"location":"features/conditional-requests/","title":"Conditional Requests","text":""},{"location":"features/conditional-requests/#conditional-requests_1","title":"Conditional Requests","text":"<p>There are built-in utilities for handling conditional requests, which serve two broad purposes:</p> <ol> <li>Sparing bandwidth on reading a document that has not changed, i.e. \"only send if the version is different from what I already have\".</li> <li>Preventing multiple writers from clobbering each other's changes, i.e. \"only save if the version on the server matches what I saw last\".</li> </ol> <p>Adding support for handling conditional requests requires four steps:</p> <ol> <li>Import the <code>github.com/danielgtaylor/huma/v2/conditional</code> package.</li> <li>(optional) Add the response definition (<code>304 Not Modified</code> for reads or <code>412 Precondition Failed</code> for writes)</li> <li>Add <code>conditional.Params</code> to your input struct.</li> <li>Check if conditional params were passed and handle them. The <code>HasConditionalParams()</code> and <code>PreconditionFailed(...)</code> methods can help with this.</li> </ol>"},{"location":"features/conditional-requests/#example","title":"Example","text":"<p>Implementing a conditional read might look like:</p> <pre><code>huma.Register(api, huma.Operation{\n\tOperationID: \"get-resource\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/resource\",\n\tSummary:     \"Get a resource\",\n}, func(ctx context.Context, input struct {\n\tconditional.Params\n}) (*YourOutput, error) {\n\tif input.HasConditionalParams() {\n\t\t// TODO: Get the ETag and last modified time from the resource.\n\t\tetag := \"\"\n\t\tmodified := time.Time{}\n\n\t\t// If preconditions fail, abort the request processing. Response status\n\t\t// codes are already set for you, but you can optionally provide a body.\n\t\t// Returns an HTTP 304 not modified.\n\t\tif err := input.PreconditionFailed(etag, modified); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Otherwise do the normal request processing here...\n\t\t// ...\n\t}\n})\n</code></pre> <p>Conditional Request Efficiency</p> <p>Note that it is more efficient to construct custom DB queries to handle conditional requests, however Huma is not aware of your database. The built-in conditional utilities are designed to be generic and work with any data source, and are a quick and easy way to get started with conditional request handling.</p>"},{"location":"features/conditional-requests/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>conditional</code> package</li> <li><code>conditional.Params</code></li> </ul> </li> <li>External Links<ul> <li>Conditional Requests</li> </ul> </li> </ul>"},{"location":"features/json-schema-registry/","title":"JSON Schema & Registry","text":""},{"location":"features/json-schema-registry/#json-schema","title":"JSON Schema","text":"<p>Using the default Huma config (or manually via the <code>huma.SchemaLinkTransformer</code>), each resource operation returns a <code>describedby</code> HTTP link relation header which references a JSON-Schema file. These schemas use the <code>config.SchemasPath</code> to serve their content. For example:</p> HTTP Response<pre><code>Link: &lt;/schemas/Note.json&gt;; rel=\"describedby\"\n</code></pre> <p>Object resources (i.e. not arrays or simple scalars) can also optionally return a <code>$schema</code> property with such a link, which enables the described-by relationship to outlive the HTTP request (i.e. saving the body to a file for later editing) and enables some editors like VSCode to provide code completion and validation as you type.</p> response.json<pre><code>{\n\t\"$schema\": \"http://localhost:8888/schemas/Note.json\",\n\t\"title\": \"I am a note title\",\n\t\"contents\": \"Example note contents\",\n\t\"labels\": [\"todo\"]\n}\n</code></pre> <p>Operations which accept objects as input will ignore the <code>$schema</code> property, so it is safe to submit back to the API, aka \"round-trip\" the data.</p> <p>Editing</p> <p>The <code>$schema</code> field is incredibly powerful when paired with Restish's edit command, giving you a quick and easy way to edit strongly-typed resources in your favorite editor.</p>"},{"location":"features/json-schema-registry/#schema-registry","title":"Schema Registry","text":"<p>Huma uses a customizable registry to keep track of all the schemas that have been generated from Go structs. This is used to avoid generating the same schema multiple times, and to provide a way to reference schemas by name for OpenAPI operations &amp; hosted JSON Schemas.</p> <p>The default schema implementation uses a <code>map</code> to store schemas by name,generated from the Go type name without the package name. This supports recursive schemas and generates simple names like <code>Thing</code> or <code>ThingList</code>.</p> <p>Schema Names</p> <p>Note that by design the default registry does not support multiple models with the same name in different packages. For example, adding both <code>foo.Thing</code> and <code>bar.Thing</code> will result in a conflict. You can work around this by defining a new type like <code>type BarThing bar.Thing</code> and using that instead, or using a custom registry naming function.</p>"},{"location":"features/json-schema-registry/#custom-registry","title":"Custom Registry","text":"<p>You can create your own registry with custom behavior by implementing the <code>huma.Registry</code> interface and setting it on <code>config.OpenAPI.Components.Schemas</code> when creating your API.</p>"},{"location":"features/json-schema-registry/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Schema</code> is a JSON Schema</li> <li><code>huma.Registry</code> generates &amp; stores JSON Schemas</li> <li><code>huma.DefaultSchemaNamer</code> names schemas from types</li> <li><code>huma.Config</code> the API config</li> <li><code>huma.DefaultConfig</code> the default API config</li> <li><code>huma.OpenAPI</code> the OpenAPI spec</li> <li><code>huma.Components</code> contains the <code>Schemas</code> registry</li> </ul> </li> <li>External Links<ul> <li>JSON Schema spec</li> <li>OpenAPI 3.1 Components Object</li> </ul> </li> <li>See Also<ul> <li>Model Validation utility to validate custom JSON objects</li> </ul> </li> </ul>"},{"location":"features/middleware/","title":"Middleware","text":""},{"location":"features/middleware/#middleware_1","title":"Middleware","text":"<p>Huma has support for two variants of middleware:</p> <ol> <li>Router-specific - works at the router level, i.e. before router-agnostic middleware. You can use any middleware that is implemented for your router.</li> <li>Router-agnostic - runs in the Huma processing chain, i.e. after calls to router-specific middleware.</li> </ol> <pre><code>graph LR\n\tRequest([Request])\n\tRouterSpecificMiddleware[Router-Specific Middleware]\n\tHumaMiddleware[Huma Middleware]\n\tOperationHandler[Operation Handler]\n\n\tRequest --&gt; RouterSpecificMiddleware\n\tRouterSpecificMiddleware --&gt; HumaMiddleware\n\tsubgraph Huma\n\t\tHumaMiddleware --&gt; OperationHandler\n\tend</code></pre>"},{"location":"features/middleware/#router-specific","title":"Router-specific","text":"<p>Each router implementation has its own middlewares, you can use these as you normally would before creating the Huma API instance.</p> <p>Chi router example:</p> code.go<pre><code>router := chi.NewMux()\nrouter.Use(jwtauth.Verifier(tokenAuth))\napi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n</code></pre> <p>Fiber router example:</p> code.go<pre><code>app := fiber.New()\napp.Use(logger.New())\napi := humafiber.New(app, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n</code></pre> <p>Huma v1</p> <p>Huma v1 middleware is compatible with Chi v4, so if you use that router with Huma v2 you can continue to use the Huma v1 middleware. See <code>humachi.NewV4</code>.</p>"},{"location":"features/middleware/#router-agnostic","title":"Router-agnostic","text":"<p>You can write you own Huma middleware without any dependency to the specific router implementation. This uses the router-agnostic <code>huma.Context</code> interface, which exposes the request and response properties to your middleware.</p> <p>Example:</p> code.go<pre><code>func MyMiddleware(ctx huma.Context, next func(huma.Context)) {\n\t// Call the next middleware in the chain. This eventually calls the\n\t// operation handler as well.\n\tnext(ctx)\n\n\t// Set a custom header on the response *after* the operation handler\n\t// has finished.\n\tctx.SetHeader(\"My-Custom-Header\", \"Hello, world!\")\n}\n\nfunc NewHumaAPI() huma.API {\n\t// ...\n\tapi := humachi.New(router, config)\n\tapi.UseMiddleware(MyMiddleware)\n}\n</code></pre>"},{"location":"features/middleware/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Context</code> a router-agnostic request/response context</li> <li><code>huma.Middlewares</code> the API instance</li> <li><code>huma.API</code> the API instance</li> </ul> </li> </ul>"},{"location":"features/model-validation/","title":"Model Validation","text":""},{"location":"features/model-validation/#model-validation_1","title":"Model Validation","text":"<p>Huma includes a utility to make it a little easier to validate models outside of the normal HTTP request/response flow, for example on app startup to load example or default data and verify it is correct. This is just a thin wrapper around the built-in validation functionality, but abstracts away some of the boilerplate required for efficient operation and provides a simple API.</p> code.go<pre><code>type MyExample struct {\n\tName string `json:\"name\" maxLength:\"5\"`\n\tAge int `json:\"age\" minimum:\"25\"`\n}\n\nvar value any\njson.Unmarshal([]byte(`{\"name\": \"abcdefg\", \"age\": 1}`), &amp;value)\n\nvalidator := huma.ModelValidator()\nerrs := validator.Validate(reflect.TypeOf(MyExample{}), value)\nif errs != nil {\n\tfmt.Println(\"Validation error\", errs)\n}\n</code></pre> <p>Concurrency</p> <p>The <code>huma.ModelValidator</code> is not goroutine-safe! For more flexible validation, use the <code>huma.Validate</code> function directly and provide your own registry, path buffer, validation result struct, etc.</p>"},{"location":"features/model-validation/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.ModelValidator</code> the model validator utility</li> </ul> </li> <li>External Links<ul> <li>JSON Schema spec</li> <li>OpenAPI 3.1 spec</li> </ul> </li> <li>See Also<ul> <li>Config &amp; OpenAPI</li> </ul> </li> </ul>"},{"location":"features/openapi-generation/","title":"Configuration &amp; Open API","text":""},{"location":"features/openapi-generation/#configuration-open-api_1","title":"Configuration &amp; Open API","text":"<p>Huma generates Open API 3.1 compatible JSON/YAML specs and provides rendered documentation automatically. Every operation that is registered with the API is included in the spec by default. The operation's inputs and outputs are used to generate the request and response parameters / schemas.</p> <p>The <code>huma.Config</code> controls where the OpenAPI, docs, and schemas are available. The default config uses <code>/openapi.json</code>, <code>/docs</code>, and <code>/schemas</code> respectively. You can change these to whatever you want, or disable them entirely by leaving them blank.</p> <p>You may want to customize the generated Open API spec. With Huma v2 you have full access and can modify it as needed in the API configuration or when registering operations. For example, to set up and then use a security scheme:</p> code.go<pre><code>config := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.Components.SecuritySchemes = map[string]*huma.SecurityScheme{\n\t\t\"bearer\": {\n\t\t\tType: \"http\",\n\t\t\tScheme: \"bearer\",\n\t\t\tBearerFormat: \"JWT\",\n\t\t},\n\t}\napi := humachi.New(router, config)\n\nhuma.Register(api, huma.Operation{\n\tOperationID: \"get-greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSummary:     \"Get a greeting\",\n\tSecurity: []map[string][]string{\n\t\t{\"bearer\": {}},\n\t},\n}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// ...\n})\n</code></pre> <p>Spec</p> <p>See the OpenAPI 3.1 spec and Huma's OpenAPI struct for everything that can be set and how it is expected to be used.</p>"},{"location":"features/openapi-generation/#openapi-settings-composition","title":"OpenAPI Settings Composition","text":"<p>Because you have full access to the OpenAPI spec, you can compose it however you want and write convenience functions to make things more straightforward. The above example could be made easier to read:</p> code.go<pre><code>config := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig = withBearerAuthScheme(config)\n\napi := humachi.New(router, config)\n\nhuma.Register(api, withBearerAuth(huma.Operation{\n\tOperationID: \"get-greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSummary:     \"Get a greeting\",\n}), func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// ...\n})\n</code></pre> <p>Set this up however you like. Even the <code>huma.Register</code> function can be wrapped or replaced by your organization to ensure that all operations are registered with the same settings.</p>"},{"location":"features/openapi-generation/#custom-openapi-extensions","title":"Custom OpenAPI Extensions","text":"<p>Custom extensions to the OpenAPI are supported via the <code>Extensions</code> field on most OpenAPI structs:</p> code.go<pre><code>config := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.Extensions = map[string]any{\n\t\"my-extension\": \"my-value\",\n}\n</code></pre> <p>Anything in the <code>Extensions</code> map will be flattened during serialization so that its fields are peers with the <code>Extensions</code> peers in the OpenAPI spec. For example, the above would result in:</p> openapi.json<pre><code>{\n\t\"openapi\": \"3.1.0\",\n\t\"info\": {\n\t\t\"title\": \"My API\",\n\t\t\"version\": \"1.0.0\"\n\t},\n\t\"my-extension\": \"my-value\"\n}\n</code></pre>"},{"location":"features/openapi-generation/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Your First API includes using the default config</li> </ul> </li> <li>Reference<ul> <li><code>huma.Config</code> the API config</li> <li><code>huma.DefaultConfig</code> the default API config</li> <li><code>huma.OpenAPI</code> the OpenAPI spec</li> <li><code>huma.API</code> the API instance</li> <li><code>huma.Register</code> registers new operations</li> </ul> </li> <li>External Links<ul> <li>OpenAPI 3.1 spec</li> </ul> </li> </ul>"},{"location":"features/operations/","title":"Operations","text":""},{"location":"features/operations/#operations_1","title":"Operations","text":"<p>Operations are at the core of Huma. They map an HTTP method verb and resource path to a handler function with well-defined inputs and outputs. When looking at an API made up of resources, the operations correspond to the <code>GET</code>, <code>POST</code>, <code>PUT</code>, etc methods on those resources like in the example below:</p> <pre><code>graph TD\n    subgraph Operations\n        GET\n        GET2[GET]\n        POST\n        PUT\n        DELETE\n    end\n\n    API --&gt; Resource1[Resource /items]\n    API --&gt; Resource2[\"Resource /users/{user-id}\"]\n\n    Resource1 --&gt; POST\n    Resource1 --&gt; GET\n    Resource1 --&gt; DELETE\n    Resource2 --&gt; GET2\n    Resource2 --&gt; PUT</code></pre> <p>Operations are created using the <code>huma.Register</code> function:</p> <pre><code>huma.Register(api, huma.Operation{\n\tOperationID: \"your-operation-name\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/path/to/resource/{id}\",\n\tSummary:     \"A short description of the operation\",\n}, func(ctx context.Context, input *YourInput) (*YourOutput, error) {\n\t// ... Implementation goes here ...\n})\n</code></pre> <p>REST</p> <p>If following REST-ish conventions, operation paths should be nouns, and plural if they return more than one item. Good examples: <code>/notes</code>, <code>/likes</code>, <code>/users/{user-id}</code>, <code>/videos/{video-id}/stats</code>, etc. Huma does not enforce this or care, so RPC-style paths are also fine to use. Use what works best for you and your team.</p> <p>OperationID</p> <p>Did you know? The <code>OperationID</code> is used to generate friendly CLI commands in Restish and used when generating SDKs! It should be unique, descriptive, and easy to type.</p> Terminal<pre><code>$ restish your-api your-operation-name --param=value ...\n</code></pre>"},{"location":"features/operations/#handler-function","title":"Handler Function","text":"<p>The operation handler function always has the following generic format, where <code>Input</code> and <code>Output</code> are custom structs defined by the developer that represent the entirety of the request (path/query/header params &amp; body) and response (headers &amp; body), respectively:</p> code.go<pre><code>func(context.Context, *Input) (*Output, error)\n</code></pre> <p>There are many options available for configuring OpenAPI settings for the operation, and custom extensions are supported as well. See the <code>huma.Operation</code> struct for more details.</p>"},{"location":"features/operations/#input-output-models","title":"Input &amp; Output Models","text":"<p>Inputs and outputs are always structs that represent the entirety of the incoming request or outgoing response. This is a deliberate design decision to make it easier to reason about the data flow in your application. It also makes it easier to share code as well as generate documentation and SDKs.</p> <p>If your operation has no inputs or outputs, you can use a pointer to an empty struct <code>*struct{}</code> when registering it.</p> code.go<pre><code>func(ctx context.Context, input *struct{}) (*struct{}, error) {\n    // Successful response example, defaults to HTTP 204 No Content\n    return nil, nil\n}\n</code></pre>"},{"location":"features/operations/#request-flow","title":"Request Flow","text":"<p>A request flowing into the API goes through a number of steps before reaching your operation handler. The following diagram shows the flow of a request through the system, from request inputs like path/query/header parameters and the request body, through validation, the operation handler, and how outputs are sent in the response.</p> <pre><code>graph LR\n    subgraph Inputs\n        Path\n        Query\n        Header\n        Body\n        RawBody\n    end\n\n    subgraph Outputs\n        Status\n        Headers\n        OutBody[Body]\n    end\n\n    Path --&gt; Validate\n    Query --&gt; Validate\n    Header --&gt; Validate\n    Body --&gt; Unmarshal --&gt; Validate\n    Validate --&gt; Resolve --&gt; Operation\n    RawBody --&gt;|raw body input| Operation\n    Operation --&gt; Transform\n    Transform --&gt; Status\n    Transform --&gt; Headers\n    Transform --&gt; Marshal --&gt; OutBody\n    Operation --&gt;|raw body output| OutBody\n\n    style Operation stroke:#f9f,stroke-width:2px,stroke-dasharray: 5 5</code></pre> <code>Unmarshal</code> <p>Read the raw bytes of the request body (e.g. JSON) into a Go structure.</p> <code>Validate</code> <p>Check constraints on the inputs (e.g. <code>minimum</code>, <code>maxLength</code>, etc) and report failures.</p> <code>Resolve</code> <p>Run custom validation code and report failures.</p> <code>Operation</code> <p>Your operation handler function. Business logic goes here. It returns either your response structure or an error.</p> <code>Transform</code> <p>Modify the structured response data on the fly before marshaling it to bytes.</p> <code>Marshal</code> <p>Convert the structured response data into bytes (e.g. JSON).</p> <p>Read on to learn about how each of these steps works.</p>"},{"location":"features/operations/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Your First API includes registering an operation</li> </ul> </li> <li>Reference<ul> <li><code>huma.Register</code> registers new operations</li> <li><code>huma.Operation</code> the operation</li> </ul> </li> <li>External Links<ul> <li>OpenAPI 3.1 Operation Object</li> </ul> </li> </ul>"},{"location":"features/request-inputs/","title":"Request Inputs","text":""},{"location":"features/request-inputs/#parameters","title":"Parameters","text":"<p>Requests can have parameters and/or a body as input to the handler function. Inputs use standard Go structs with special fields and/or tags. Here are the available tags:</p> Tag Description Example <code>path</code> Name of the path parameter <code>path:\"thing-id\"</code> <code>query</code> Name of the query string parameter <code>query:\"q\"</code> <code>header</code> Name of the header parameter <code>header:\"Authorization\"</code> <code>required</code> Mark a query/header param as required <code>required:\"true\"</code> <p>Required</p> <p>The <code>required</code> tag is discouraged and is only used for query/header params, which should generally be optional for clients to send.</p>"},{"location":"features/request-inputs/#parameter-types","title":"Parameter Types","text":"<p>The following parameter types are supported out of the box:</p> Type Example Inputs <code>bool</code> <code>true</code>, <code>false</code> <code>[u]int[16/32/64]</code> <code>1234</code>, <code>5</code>, <code>-1</code> <code>float32/64</code> <code>1.234</code>, <code>1.0</code> <code>string</code> <code>hello</code>, <code>t</code> <code>time.Time</code> <code>2020-01-01T12:00:00Z</code> slice, e.g. <code>[]int</code> <code>1,2,3</code>, <code>tag1,tag2</code> <p>For example, if the parameter is a query param and the type is <code>[]string</code> it might look like <code>?tags=tag1,tag2</code> in the URI.</p>"},{"location":"features/request-inputs/#request-body","title":"Request Body","text":"<p>The special struct field <code>Body</code> will be treated as the input request body and can refer to any other type or you can embed a struct or slice inline. If the body is a pointer, then it is optional. All doc &amp; validation tags are allowed on the body in addition to these tags:</p> Tag Description Example <code>contentType</code> Override the content type <code>contentType:\"application/octet-stream\"</code> <code>required</code> Mark the body as required <code>required:\"true\"</code> <p><code>RawBody []byte</code> can also be used alongside <code>Body</code> or standalone to provide access to the <code>[]byte</code> used to validate &amp; parse <code>Body</code>, or to the raw input without any validation/parsing.</p>"},{"location":"features/request-inputs/#request-example","title":"Request Example","text":"<p>Here is an example request input struct, which has a path param, query param, header param, and a structured body alongside the raw body bytes:</p> code.go<pre><code>type MyInput struct {\n\tID      string `path:\"id\"`\n\tDetail  bool   `query:\"detail\" doc:\"Show full details\"`\n\tAuth    string `header:\"Authorization\"`\n\tBody    MyBody\n\tRawBody []byte\n}\n</code></pre> <p>A request to such an endpoint might look like:</p> Terminal<pre><code># Via high-level operations:\n$ restish api my-op 123 --detail=true --authorization=foo &lt;body.json\n\n# Via URL:\n$ restish api/my-op/123?detail=true -H \"Authorization: foo\" &lt;body.json\n</code></pre> <p>Uploads</p> <p>You can use <code>RawBody []byte</code> without a corresponding <code>Body</code> field in order to support small file uploads.</p>"},{"location":"features/request-inputs/#input-composition","title":"Input Composition","text":"<p>Because inputs are just Go structs, they are composable and reusable. For example:</p> code.go<pre><code>type AuthParam struct {\n\tAuthorization string `header:\"Authorization\"`\n}\n\ntype PaginationParams struct {\n\tCursor string `query:\"cursor\"`\n\tLimit  int    `query:\"limit\"`\n}\n\n// ... Later in the code\nhuma.Register(api, huma.Operation{\n\tOperationID: \"list-things\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/things\",\n\tSummary:     \"Get a filtered list of things\",\n}, func(ctx context.Context, input struct {\n\t// Embed both structs to compose your input.\n\tAuthParam\n\tPaginationParams\n}) (*struct{}, error) {\n\tfmt.Printf(\"Auth: %s, Cursor: %s, Limit: %d\\n\", input.Authorization, input.Cursor, input.Limit)\n\treturn nil, nil\n}\n</code></pre>"},{"location":"features/request-inputs/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Your First API includes registering an operation with a path param</li> </ul> </li> <li>Reference<ul> <li><code>huma.Register</code> registers new operations</li> <li><code>huma.Operation</code> the operation</li> </ul> </li> <li>External Links<ul> <li>OpenAPI 3.1 Operation Object</li> <li>OpenAPI 3.1 Parameter Object</li> </ul> </li> </ul>"},{"location":"features/request-limits/","title":"Request Limits","text":""},{"location":"features/request-limits/#deadlines-timeouts","title":"Deadlines &amp; Timeouts","text":"<p>A combination of the server and the request context can be used to control deadlines &amp; timeouts. Go's built-in HTTP server supports a few timeout settings:</p> code.go<pre><code>srv := &amp;http.Server{\n\tReadTimeout:       5 * time.Second,\n\tWriteTimeout:      5 * time.Second,\n\tIdleTimeout:       30 * time.Second,\n\tReadHeaderTimeout: 2 * time.Second,\n\t// ...\n}\n</code></pre> <p>The Huma request context (accessible via resolvers) can be used to set a read deadline, which can be used to process large or streaming inputs:</p> code.go<pre><code>type MyInput struct {}\n\nfunc (m *MyInput) Resolve(ctx huma.Context) []error {\n\tctx.SetReadDeadline(time.Now().Add(5 * time.Second))\n}\n</code></pre> <p>Additionally, a <code>context.Context</code> can be used to set a deadline for dependencies like databases:</p> code.go<pre><code>// Create a new context with a 10 second timeout.\nnewCtx, cancel := context.WithTimeout(ctx, 10 * time.Second)\ndefer cancel()\n\n// Use the new context for any dependencies.\nresult, err := myDB.Get(newCtx, /* ... */)\nif err != nil {\n\t// Deadline may have been hit, handle it here!\n}\n</code></pre>"},{"location":"features/request-limits/#body-size-limits","title":"Body Size Limits","text":"<p>By default each operation has a 1 MiB request body size limit. This can be changed by setting <code>huma.Operation.MaxBodyBytes</code> to a different value when registering the operation. If the request body is larger than the limit then a <code>413 Request Entity Too Large</code> error will be returned.</p> code.go<pre><code>huma.Register(api, huma.Operation{\n\tOperationID:  \"put-thing\",\n\tMethod:       http.MethodPut,\n\tPath:         \"/things/{thing-id}\",\n\tSummary:      \"Put a thing by ID\",\n\tMaxBodyBytes: 10 * 1024 * 1024, // 10 MiB\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t// Do nothing...\n\treturn nil, nil\n}\n</code></pre> <p>Keep in mind that the body is read into memory before being passed to the handler function.</p>"},{"location":"features/request-limits/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Resolver</code> is the basic interface</li> <li><code>huma.ResolverWithPath</code> has a path prefix</li> <li><code>huma.Operation</code> the operation</li> <li><code>huma.Context</code> a router-agnostic request/response context</li> </ul> </li> <li>External Links<ul> <li>Go Contexts from the Go blog</li> <li><code>context.Context</code></li> <li><code>http.Server</code></li> </ul> </li> </ul>"},{"location":"features/request-resolvers/","title":"Request Resolvers","text":""},{"location":"features/request-resolvers/#request-resolvers_1","title":"Request Resolvers","text":"<p>Sometimes the built-in validation isn't sufficient for your use-case, or you want to do something more complex with the incoming request object. This is where resolvers come in.</p> <p>Any input struct can be a resolver by implementing the <code>huma.Resolver</code> or <code>huma.ResolverWithPath</code> interface, including embedded structs. Each resolver takes the current context and can return a list of exhaustive errors. For example:</p> code.go<pre><code>// MyInput demonstrates inputs/transformation\ntype MyInput struct {\n\tHost   string\n\tName string `query:\"name\"`\n}\n\nfunc (m *MyInput) Resolve(ctx huma.Context) []error {\n\t// Get request info you don't normally have access to.\n\tm.Host = ctx.Host()\n\n\t// Transformations or other data validation\n\tm.Name = strings.Title(m.Name)\n\n\treturn nil\n}\n\n// Then use it like any other input struct:\nhuma.Register(api, huma.Operation{\n\tOperationID: \"list-things\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/things\",\n\tSummary:     \"Get a filtered list of things\",\n}, func(ctx context.Context, input *MyInput) (*YourOutput, error) {\n\tfmt.Printf(\"Host: %s\\n\", input.Host)\n\tfmt.Printf(\"Name: %s\\n\", input.Name)\n})\n</code></pre> <p>It is recommended that you do not save the context object passed to the <code>Resolve</code> method for later use.</p> <p>For deeply nested structs within the request body, you may not know the current location of the field being validated (e.g. it may appear in multiple places or be shared by multiple request objects). The <code>huma.ResolverWithPath</code> interface provides a path prefix that can be used to generate the full path to the field being validated. It uses a <code>huma.PathBuffer</code> for efficient path generation reusing a shared buffer. For example:</p> code.go<pre><code>func (m *MyInput) Resolve(ctx huma.Context, prefix *huma.PathBuffer) []error {\n\treturn []error{&amp;huma.ErrorDetail{\n\t\tMessage: \"Foo has a bad value\",\n\t\tLocation: prefix.With(\"foo\")\n\t\tValue: m.Foo,\n\t}}\n}\n</code></pre> <p>Validation Preference</p> <p>Prefer using built-in validation over resolvers whenever possible, as it will be better documented and is also usable by OpenAPI tooling to provide a better developer experience.</p>"},{"location":"features/request-resolvers/#resolver-errors","title":"Resolver Errors","text":"<p>Resolvers can set errors as needed and Huma will automatically return a 400-level error response before calling your handler. This makes resolvers a good place to run additional complex validation steps so you can provide the user with a set of exhaustive errors.</p> code.go<pre><code>type MyInput struct {\n\tHost   string\n}\n\nfunc (m *MyInput) Resolve(ctx huma.Context) []error {\n\tm.Host = ctx.Host()\n\tif m.Host == \"localhost\" {\n\t\treturn []error{&amp;huma.ErrorDetail{\n\t\t\tMessage: \"Unsupported host value!\",\n\t\t\tLocation: \"request.host\",\n\t\t\tValue: m.Host,\n\t\t}}\n\t}\n\treturn nil\n}\n</code></pre> <p>It is also possible for resolvers to return custom HTTP status codes for the response, by returning an error which satisfies the <code>huma.StatusError</code> interface. Errors are processed in the order they are returned and the last one wins, so this feature should be used sparingly. For example:</p> code.go<pre><code>type MyInput struct{}\n\nfunc (i *MyInput) Resolve(ctx huma.Context) []error {\n\treturn []error{huma.Error403Forbidden(\"nope\")}\n}\n</code></pre> <p>Why Exhaustive Errors?</p> <p>Exhaustive errors lessen frustration for users. It's better to return three errors in response to one request than to have the user make three requests which each return a new different error.</p>"},{"location":"features/request-resolvers/#implementation-check","title":"Implementation Check","text":"<p>There is a Go trick for ensuring that a struct implements a certain interface, and you can utilize it to ensure your resolvers will be called as expected. For example:</p> code.go<pre><code>// Ensure MyInput implements huma.Resolver\nvar _ huma.Resolver = (*MyInput)(nil)\n</code></pre> <p>This creates a new <code>nil</code> pointer to your struct and assigns it to an unnamed variable of type <code>huma.Resolver</code>. It will be compiled and then thrown away during optimization. If your resolver code changes and no longer implements the interface, the code will fail to compile.</p>"},{"location":"features/request-resolvers/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>How-To<ul> <li>Custom Validation includes using resolvers</li> </ul> </li> <li>Reference<ul> <li><code>huma.Resolver</code> is the basic interface</li> <li><code>huma.ResolverWithPath</code> has a path prefix</li> <li><code>huma.Context</code> a router-agnostic request/response context</li> </ul> </li> </ul>"},{"location":"features/request-validation/","title":"Request Validation","text":""},{"location":"features/request-validation/#request-validation_1","title":"Request Validation","text":"<p>Go struct tags are used to annotate inputs/output structs with information that gets turned into JSON Schema for documentation and validation.</p> <p>The standard <code>json</code> tag is supported and can be used to rename a field and mark fields as optional using <code>omitempty</code>. The following additional tags are supported on model fields:</p> Tag Description Example <code>doc</code> Describe the field <code>doc:\"Who to greet\"</code> <code>format</code> Format hint for the field <code>format:\"date-time\"</code> <code>enum</code> A comma-separated list of possible values <code>enum:\"one,two,three\"</code> <code>default</code> Default value <code>default:\"123\"</code> <code>minimum</code> Minimum (inclusive) <code>minimum:\"1\"</code> <code>exclusiveMinimum</code> Minimum (exclusive) <code>exclusiveMinimum:\"0\"</code> <code>maximum</code> Maximum (inclusive) <code>maximum:\"255\"</code> <code>exclusiveMaximum</code> Maximum (exclusive) <code>exclusiveMaximum:\"100\"</code> <code>multipleOf</code> Value must be a multiple of this value <code>multipleOf:\"2\"</code> <code>minLength</code> Minimum string length <code>minLength:\"1\"</code> <code>maxLength</code> Maximum string length <code>maxLength:\"80\"</code> <code>pattern</code> Regular expression pattern <code>pattern:\"[a-z]+\"</code> <code>minItems</code> Minimum number of array items <code>minItems:\"1\"</code> <code>maxItems</code> Maximum number of array items <code>maxItems:\"20\"</code> <code>uniqueItems</code> Array items must be unique <code>uniqueItems:\"true\"</code> <code>minProperties</code> Minimum number of object properties <code>minProperties:\"1\"</code> <code>maxProperties</code> Maximum number of object properties <code>maxProperties:\"20\"</code> <code>example</code> Example value <code>example:\"123\"</code> <code>readOnly</code> Sent in the response only <code>readOnly:\"true\"</code> <code>writeOnly</code> Sent in the request only <code>writeOnly:\"true\"</code> <code>deprecated</code> This field is deprecated <code>deprecated:\"true\"</code> <p>Parameters have some additional validation tags:</p> Tag Description Example <code>hidden</code> Hide parameter from documentation <code>hidden:\"true\"</code>"},{"location":"features/request-validation/#advanced-validation","title":"Advanced Validation","text":"<p>When using custom JSON Schemas, i.e. not generated from Go structs, it's possible to utilize a few more validation rules. The following schema fields are respected by the built-in validator:</p> <ul> <li><code>not</code> for negation</li> <li><code>oneOf</code> for exclusive inputs</li> <li><code>anyOf</code> for matching one-or-more</li> <li><code>allOf</code> for schema unions</li> </ul> <p>See <code>huma.Schema</code> for more information. Note that it may be easier to use a custom resolver to implement some of these rules.</p>"},{"location":"features/request-validation/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Your First API includes string length validation</li> </ul> </li> <li>Reference<ul> <li><code>huma.Register</code> registers new operations</li> <li><code>huma.Operation</code> the operation</li> </ul> </li> <li>External Links<ul> <li>JSON Schema Validation</li> <li>OpenAPI 3.1 Schema Object</li> <li>OpenAPI 3.1 Operation Object</li> </ul> </li> </ul>"},{"location":"features/response-errors/","title":"Response Errors","text":""},{"location":"features/response-errors/#returning-http-errors","title":"Returning HTTP Errors","text":"<p>Handler functions can return errors instead of a successful response. There are a number of utility functions to return common HTTP errors:</p> code.go<pre><code>huma.Register(api, huma.Operation{\n\t\tOperationID: \"get-thing\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/things/{thing-id}\",\n\t\tSummary:     \"Get a thing by ID\",\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t\t// Return a 404 Not Found error\n\t\treturn nil, huma.Error404NotFound(\"thing not found\")\n}\n</code></pre> <p>The error functions are named like <code>Error{code}{name}</code> and accept a message and error details which can provide more information back to the user. For example, <code>huma.Error400BadRequest(msg string, errs ...error)</code>. Editors like VSCode should automatically show the available errors as you type:</p> <p></p> <p>Default Error Response</p> <p>If the error returned has no associated HTTP status code, for example you use <code>fmt.Errorf(\"my error\")</code>, then the default error response code is <code>500 Internal Server Error</code>. Use <code>huma.NewError</code> to return an error with a custom status code.</p>"},{"location":"features/response-errors/#error-model","title":"Error Model","text":"<p>Errors use RFC 7807 Problem Details for HTTP APIs with a content type like <code>application/problem+json</code> and return a structure that looks like:</p> HTTP Response<pre><code>HTTP/2.0 422 Unprocessable Entity\nCache-Control: private\nContent-Length: 241\nContent-Type: application/problem+json\nLink: &lt;/schemas/ErrorModel.json&gt;; rel=\"describedBy\"\n\n{\n  \"$schema\": \"https://api.rest.sh/schemas/ErrorModel.json\",\n  \"status\": 422,\n  \"title\": \"Unprocessable Entity\",\n  \"detail\": \"validation failed\",\n  \"errors\": [\n    {\n      \"location\": \"body.title\",\n      \"message\": \"expected string\",\n      \"value\": true\n    },\n    {\n      \"location\": \"body.reviews\",\n      \"message\": \"unexpected property\",\n      \"value\": {\n        \"reviews\": 5,\n        \"title\": true\n      }\n    }\n  ]\n}\n</code></pre> <p>The <code>errors</code> field is optional and may contain more details about which specific errors occurred. See <code>huma.ErrorModel</code> for more details.</p> <p>To display a <code>location</code>, <code>message</code>, and <code>value</code> in the errors array, use the <code>huma.ErrorDetail</code> struct. If you need to wrap this with custom logic for any reason, you can implement the <code>huma.ErrorDetailer</code> interface.</p>"},{"location":"features/response-errors/#exhaustive-errors","title":"Exhaustive Errors","text":"<p>It is recommended to return exhaustive errors whenever possible to prevent user frustration with having to keep retrying a bad request and getting back a different error.</p> <p>Input parameters validation, body validation, resolvers, etc all support returning exhaustive errors. Because of this, it's preferable to use them over custom error logic in your operation handler.</p>"},{"location":"features/response-errors/#error-status-codes","title":"Error Status Codes","text":"<p>While every attempt is made to return exhaustive errors within Huma, each individual response can only contain a single HTTP status code. The following chart describes which codes get returned and when:</p> <pre><code>flowchart TD\n\tRequest[Request has errors?] --&gt;|yes| Panic\n\tRequest --&gt;|no| Continue[Continue to handler]\n\tPanic[Panic?] --&gt;|yes| 500\n\tPanic --&gt;|no| RequestBody[Request body too large?]\n\tRequestBody --&gt;|yes| 413\n\tRequestBody --&gt;|no| RequestTimeout[Request took too long to read?]\n\tRequestTimeout --&gt;|yes| 408\n\tRequestTimeout --&gt;|no| ParseFailure[Cannot parse input?]\n\tParseFailure --&gt;|yes| 400\n\tParseFailure --&gt;|no| ValidationFailure[Validation failed?]\n\tValidationFailure --&gt;|yes| 422\n\tValidationFailure --&gt;|no| 400</code></pre> <p>This means it is possible to, for example, get an HTTP <code>408 Request Timeout</code> response that also contains an error detail with a validation error for one of the input headers. Since request timeout has higher priority, that will be the response status code that is returned.</p>"},{"location":"features/response-errors/#custom-errors","title":"Custom Errors","text":"<p>It is possible to provide your own error model and have the built-in error utility functions use that model instead of the default one. This is useful if you want to provide more information in your error responses or your organization has requirements around the error response structure.</p> <p>This is accmplished by defining your custom model as a <code>huma.StatusError</code> and then overriding the built-in <code>huma.NewError</code> function:</p> code.go<pre><code>type MyError struct {\n\tstatus  int\n\tMessage string   `json:\"message\"`\n\tDetails []string `json:\"details,omitempty\"`\n}\n\nfunc (e *MyError) Error() string {\n\treturn e.Message\n}\n\nfunc (e *MyError) GetStatus() int {\n\treturn e.status\n}\n\nfunc main() {\n\thuma.NewError = func(status int, message string, errs ...error) huma.StatusError {\n\t\tdetails := make([]string, len(errs))\n\t\tfor i, err := range errs {\n\t\t\tdetails[i] = err.Error()\n\t\t}\n\t\treturn &amp;MyError{\n\t\t\tstatus:  status,\n\t\t\tMessage: message,\n\t\t\tDetails: details,\n\t\t}\n\t}\n\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-error\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/error\",\n\t}, func(ctx context.Context, i *struct{}) (*struct{}, error) {\n\t\treturn nil, huma.Error404NotFound(\"not found\", fmt.Errorf(\"some-other-error\"))\n\t})\n\n\thttp.ListenAndServe(\":8888\", router)\n}\n</code></pre> <p>To change the default content type that is returned, you can also implement the <code>huma.ContentTypeFilter</code> interface.</p>"},{"location":"features/response-errors/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.ErrorModel</code> the default error model</li> <li><code>huma.ErrorDetail</code> describes location &amp; value of an error</li> <li><code>huma.StatusError</code> interface for custom errors</li> <li><code>huma.ContentTypeFilter</code> interface for custom content types</li> </ul> </li> <li>External Links<ul> <li>HTTP Status Codes</li> <li>RFC 7807 Problem Details for HTTP APIs</li> </ul> </li> </ul>"},{"location":"features/response-outputs/","title":"Response Outputs","text":"<p>Responses can have an optional status code, headers, and/or body. Like inputs, they use standard Go structs which describe the entirety of the response.</p>"},{"location":"features/response-outputs/#status-code","title":"Status Code","text":"<p>Huma uses the following default response status codes:</p> <ul> <li><code>200</code> for responses with bodies</li> <li><code>204</code> for responses without a body</li> </ul> <p>You can override this behavior in two ways. The first is by setting <code>huma.Operation</code> <code>DefaultStatus</code> field at operation registration time.</p> code.go<pre><code>// Register an operation with a default status code of 201.\nhuma.Register(api, huma.Operation{\n\tOperationID:  \"create-thing\",\n\tMethod:       http.MethodPost,\n\tPath:         \"/things\",\n\tSummary:      \"Create a thing\",\n\tDefaultStatus: 201,\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t// Do nothing...\n\treturn nil, nil\n}\n</code></pre> <p>If the response code needs to be dynamic, you can use the special <code>Status</code> field in your response struct. This is not recommended, but is available if needed.</p> code.go<pre><code>type ThingResponse struct {\n\tStatus int\n}\n\nhuma.Register(api, huma.Operation{\n\tOperationID:  \"get-thing\",\n\tMethod:       http.MethodGet,\n\tPath:         \"/things/{thing-id}\",\n\tSummary:      \"Get a thing by ID\",\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t// Create a response and set the dynamic status\n\tresp := &amp;ThingResponse{}\n\tif input.ID &lt; 500 {\n\t\tresp.Status = 200\n\t} else {\n\t\t// This is a made-up status code used for newer things.\n\t\tresp.Status = 250\n\t}\n\treturn resp, nil\n}\n</code></pre> <p>Dynamic Status</p> <p>It is much more common to set the default status code than to need a <code>Status</code> field in your response struct!</p>"},{"location":"features/response-outputs/#headers","title":"Headers","text":"<p>Headers are set by fields on the response struct. Here are the available tags:</p> Tag Description Example <code>header</code> Name of the response header <code>header:\"Authorization\"</code> <p>Here's an example of a response with several headers of different types:</p> code.go<pre><code>// Example struct with several headers\ntype MyOutput struct {\n\tContentType  string    `header:\"Content-Type\"`\n\tLastModified time.Time `header:\"Last-Modified\"`\n\tMyHeader     int       `header:\"My-Header\"`\n}\n</code></pre>"},{"location":"features/response-outputs/#body","title":"Body","text":"<p>The special struct field <code>Body</code> will be treated as the response body and can refer to any other type or you can embed a struct or slice inline. A default <code>Content-Type</code> header will be set if none is present, selected via client-driven content negotiation with the server based on the registered serialization types.</p> <p>Example:</p> code.go<pre><code>type MyBody struct {\n\tName string `json:\"name\"`\n}\n\ntype MyOutput struct {\n\tBody MyBody\n}\n</code></pre> <p>Use a type of <code>[]byte</code> to bypass serialization.</p> code.go<pre><code>type MyOutput struct {\n\tBody []byte\n}\n</code></pre> <p>You can also stream the response body, see streaming for more details.</p>"},{"location":"features/response-outputs/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Register</code> registers new operations</li> <li><code>huma.Operation</code> the operation</li> </ul> </li> <li>External Links<ul> <li>HTTP Status Codes</li> </ul> </li> </ul>"},{"location":"features/response-serialization/","title":"Serialization","text":"<p>When handler functions return Go objects, they will be serialized to bytes for transmission back to the client.</p>"},{"location":"features/response-serialization/#default-formats","title":"Default Formats","text":"<p>The <code>config.Formats</code> maps either a content type name or extension (suffix) to a <code>huma.Format</code> instance.</p> <p>The default configuration for Huma includes support for JSON (RFC 8259) and CBOR (RFC 7049) content types via the <code>Accept</code> header. This is done by registering the following content types using <code>huma.DefaultJSONFormat</code> &amp; <code>huma.DefaultCBORFormat</code>:</p> <ul> <li><code>application/json</code></li> <li>Anything ending with <code>+json</code></li> <li><code>application/cbor</code></li> <li>Anything ending with <code>+cbor</code></li> </ul> <p>Other Formats</p> <p>You can easily add support for additional serialization formats, including binary formats like Protobuf if desired.</p>"},{"location":"features/response-serialization/#custom-formats","title":"Custom Formats","text":"<p>Huma supports custom serialization formats by implementing the <code>huma.Format</code> interface. Serialization formats are set on the API configuration at API creation time and selected by client-driven content negotiation.</p> <p>Writing a new format can be very simple, by just providing a marshal and unmarshal function:</p> code.go<pre><code>var DefaultJSONFormat = Format{\n\tMarshal: func(w io.Writer, v any) error {\n\t\treturn json.NewEncoder(w).Encode(v)\n\t},\n\tUnmarshal: json.Unmarshal,\n}\n</code></pre>"},{"location":"features/response-serialization/#content-negotiation","title":"Content Negotiation","text":"<p>Content negotiation allows clients to select the content type they are most comfortable working with when talking to the API. For request bodies, this uses the <code>Content-Type</code> header. For response bodies, it uses the <code>Accept</code> header. If none are present then JSON is usually selected as the default / preferred content type.</p> Terminal<pre><code># Send YAML as input using Restish\n$ echo 'foo: bar' | \\\n\trestish put api.rest.sh -H 'Content-Type:application/yaml'\n\n# Get CBOR output from an API\n$ restish api.rest.sh -H 'Accept:application/cbor'\nHTTP/2.0 200 OK\nContent-Length: 318\nContent-Type: application/cbor\nEtag: O7fTqWETqWI\n...\n</code></pre> <p>See the <code>negotiation</code> package for more info.</p>"},{"location":"features/response-serialization/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Config</code> the API config</li> <li><code>huma.DefaultConfig</code> the default API config</li> <li><code>huma.Format</code> to marshal/unmarshal data</li> </ul> </li> <li>External Links<ul> <li>RFC 8259 JSON</li> <li>RFC 7049 CBOR</li> </ul> </li> </ul>"},{"location":"features/response-streaming/","title":"Streaming","text":""},{"location":"features/response-streaming/#streaming_1","title":"Streaming","text":"<p>The response <code>Body</code> can be a callback function taking a <code>huma.Context</code> to facilitate streaming. The <code>huma.StreamResponse</code> utility makes this easy to return:</p> code.go<pre><code>func handler(ctx context.Context, input *MyInput) (*huma.StreamResponse, error) {\n\treturn &amp;huma.StreamResponse{\n\t\tBody: func(ctx huma.Context) {\n\t\t\t// Write header info before streaming the body.\n\t\t\tctx.SetHeader(\"Content-Type\", \"text/my-stream\")\n\t\t\twriter := ctx.BodyWriter()\n\n\t\t\t// Update the write deadline to give us extra time.\n\t\t\tif d, ok := writer.(interface{ SetWriteDeadline(time.Time) error }); ok {\n\t\t\t\td.SetWriteDeadline(time.Now().Add(5 * time.Second))\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"warning: unable to set write deadline\")\n\t\t\t}\n\n\t\t\t// Write the first message, then flush and wait.\n\t\t\twriter.Write([]byte(\"Hello, I'm streaming!\"))\n\t\t\tif f, ok := writer.(http.Flusher); ok {\n\t\t\t\tf.Flush()\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"error: unable to flush\")\n\t\t\t}\n\n\t\t\ttime.Sleep(3 * time.Second)\n\n\t\t\t// Write the second message.\n\t\t\twriter.Write([]byte(\"Hello, I'm still streaming!\"))\n\t\t},\n\t}, nil\n}\n</code></pre> <p>Also take a look at <code>http.ResponseController</code> which can be used to set timeouts, flush, etc in one simple interface.</p> <p>Server Sent Events</p> <p>The <code>sse</code> package provides a helper for streaming Server-Sent Events (SSE) responses that is easier to use than the above example!</p>"},{"location":"features/response-streaming/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Context</code> a router-agnostic request/response context</li> <li><code>huma.StreamResponse</code> for streaming output</li> </ul> </li> <li>External Links<ul> <li>Server Sent Events for one-way streaming</li> </ul> </li> </ul>"},{"location":"features/response-transformers/","title":"Response Transformers","text":""},{"location":"features/response-transformers/#response-transformers_1","title":"Response Transformers","text":"<p>Router middleware operates on router-specific request &amp; response objects whose bodies are <code>[]byte</code> slices or streams. Huma operations operate on specific struct instances. Sometimes there is a need to generically operate on structured response data after the operation handler has run but before the response is serialized to bytes. This is where response transformers come in.</p> <pre><code>flowchart LR\n\tRequest --&gt; Middleware\n\tMiddleware --&gt; Unmarshal\n\tsubgraph Huma\n\t\tUnmarshal --&gt; Handler\n\t\tHandler --&gt; Transformer\n\t\tTransformer --&gt; Marshal\n\tend\n\tMarshal --&gt; Response\n\n\tstyle Transformer stroke:#f9f,stroke-width:2px,stroke-dasharray: 5 5</code></pre> <p>Response transformers enable you to modify the response on the fly. For example, you could add a <code>Link</code> header to the response to indicate that the response body is described by a JSON Schema. This is done by implementing the <code>huma.Transformer</code> interface and registering it with the API.</p> <p>A simple for-fun example might look something like this:</p> code.go<pre><code>// FieldSelectTransform is an example of a transform that can use an input\n// header value to modify the response on the server, providing a GraphQL-like\n// way to send only the fields that the client wants over the wire.\nfunc FieldSelectTransform(ctx Context, status string, v any) (any, error) {\n\tif fields := ctx.Header(\"Fields\"); fields != \"\" {\n\t\t// Ugh this is inefficient... consider other ways of doing this :-(\n\t\tvar tmp any\n\t\tb, _ := json.Marshal(v)\n\t\tjson.Unmarshal(b, &amp;tmp)\n\t\tresult, _, err := shorthand.GetPath(fields, tmp, shorthand.GetOptions{})\n\t\treturn result, err\n\t}\n\treturn v, nil\n}\n</code></pre> <p>This could be used like so:</p> Terminal<pre><code>$ restish example.com/things/1 -H 'Fields: {id, tag_names: tags[].name}'\n</code></pre> <p>See the <code>huma.SchemaLinkTransformer</code> for a more real-world in-depth example.</p>"},{"location":"features/response-transformers/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Transformer</code> response transformers</li> <li><code>huma.Config</code> the API config</li> </ul> </li> </ul>"},{"location":"features/schema-customization/","title":"Schema Customization","text":""},{"location":"features/schema-customization/#operation-schema","title":"Operation Schema","text":"<p>Schemas that are generated for input/output bodies can be customized in a couple of different ways. First, when registering your operation you can provide your own request and/or response schemas if you want to override the entire body. The automatic generation only applies when you have not provided your own schema in the OpenAPI.</p> code.go<pre><code>// Register an operation with a custom input body schema.\nhuma.Register(api, huma.Operation{\n\tOperationID: \"my-operation\",\n\tMethod:      http.MethodPut,\n\tPath:        \"/things/{thing-id}\",\n\tSummary:     \"Update a thing\",\n\tRequestBody: &amp;huma.RequestBody{\n\t\tDescription: \"My custom request schema\",\n\t\tContent: map[string]*huma.MediaType{\n\t\t\t\"application/json\": {\n\t\t\t\tSchema: &amp;huma.Schema{\n\t\t\t\t\tType: \t\t huma.TypeObject,\n\t\t\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\t\t\"foo\": {\n\t\t\t\t\t\t\tType: huma.TypeString,\n\t\t\t\t\t\t\tExtensions: map[string]any{\n\t\t\t\t\t\t\t\t\"x-custom-thing\": \"abc123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n}, func(ctx context.Context, input *MyInput) (*MyOutput, error) {\n\t// Implementation goes here...\n\treturn nil, nil\n})\n</code></pre>"},{"location":"features/schema-customization/#field-schema","title":"Field Schema","text":"<p>Second, this can be done on a per-field basis by making a struct that implements a special interface to get a schema, allowing you to e.g. encapsulate additional functionality within that field. This is the interface:</p> code.go<pre><code>// SchemaProvider is an interface that can be implemented by types to provide\n// a custom schema for themselves, overriding the built-in schema generation.\n// This can be used by custom types with their own special serialization rules.\ntype SchemaProvider interface {\n\tSchema(r huma.Registry) *huma.Schema\n}\n</code></pre> <p>The <code>huma.Registry</code> is passed to you and can be used to get schemas or refs for any embedded structs. Here is an example, where we want to know if a field was omitted vs. null vs. a value when sent as part of a request body. First we start by defininig the custom generic struct:</p> code.go<pre><code>// OmittableNullable is a field which can be omitted from the input,\n// set to `null`, or set to a value. Each state is tracked and can\n// be checked for in handling code.\ntype OmittableNullable[T any] struct {\n\tSent  bool\n\tNull  bool\n\tValue T\n}\n\n// UnmarshalJSON unmarshals this value from JSON input.\nfunc (o *OmittableNullable[T]) UnmarshalJSON(b []byte) error {\n\tif len(b) &gt; 0 {\n\t\to.Sent = true\n\t\tif bytes.Equal(b, []byte(\"null\")) {\n\t\t\to.Null = true\n\t\t\treturn nil\n\t\t}\n\t\treturn json.Unmarshal(b, &amp;o.Value)\n\t}\n\treturn nil\n}\n\n// Schema returns a schema representing this value on the wire.\n// It returns the schema of the contained type.\nfunc (o OmittableNullable[T]) Schema(r huma.Registry) *huma.Schema {\n\treturn r.Schema(reflect.TypeOf(o.Value), true, \"\")\n}\n</code></pre> <p>This is how it can be used in an operation:</p> <pre><code>type MyResponse struct {\n\tBody struct {\n\t\tMessage string `json:\"message\"`\n\t}\n}\n\nhuma.Register(api, huma.Operation{\n\tOperationID: \"omittable\",\n\tMethod:      http.MethodPost,\n\tPath:        \"/omittable\",\n\tSummary:     \"Omittable / nullable example\",\n}, func(ctx context.Context, input *struct {\n\t// Making the body a pointer makes it optional, as it may be `nil`.\n\tBody *struct {\n\t\tName OmittableNullable[string] `json:\"name,omitempty\" maxLength:\"10\"`\n\t}\n}) (*MyResponse, error) {\n\tresp := &amp;MyResponse{}\n\tif input.Body == nil {\n\t\tresp.Body.Message = \"Body was not sent\"\n\t} else if !input.Body.Name.Sent {\n\t\tresp.Body.Message = \"Name was omitted from the request\"\n\t} else if input.Body.Name.Null {\n\t\tresp.Body.Message = \"Name was set to null\"\n\t} else {\n\t\tresp.Body.Message = \"Name was set to: \" + input.Body.Name.Value\n\t}\n\treturn resp, nil\n})\n</code></pre> <p>If you go to view the generated docs, you will see that the type of the <code>name</code> field is <code>string</code> and that it is optional, with a max length of 10, indicating that the custom schema was correctly used in place of one generated for the <code>OmittableNullable[string]</code> struct.</p> <p>See https://github.com/danielgtaylor/huma/blob/main/examples/omit/main.go for a full example along with how to call it. This just scratches the surface of what's possible with custom schemas for fields.</p>"},{"location":"features/schema-customization/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Schema</code> is a JSON Schema</li> <li><code>huma.Registry</code> generates &amp; stores JSON Schemas</li> <li><code>huma.DefaultSchemaNamer</code> names schemas from types</li> </ul> </li> <li>External Links<ul> <li>JSON Schema spec</li> <li>OpenAPI 3.1 spec</li> </ul> </li> <li>See Also<ul> <li>Config &amp; OpenAPI</li> </ul> </li> </ul>"},{"location":"features/server-sent-events-sse/","title":"Server Sent Events (SSE)","text":""},{"location":"features/server-sent-events-sse/#sse","title":"SSE","text":"<p>The <code>sse</code> package provides a helper for streaming Server-Sent Events (SSE) responses.</p> <p>SSE is a simple protocol for sending events from the server to the client over HTTP. It is a one-way protocol, meaning that the client cannot send events to the server, but can consume them as they are sent. It is popularly used as a push mechanism for web and other clients.</p>"},{"location":"features/server-sent-events-sse/#example","title":"Example","text":"<p>The <code>sse</code> package provides a simple API for sending events to the client and documents the event types and data structures in the OpenAPI spec if you provide a mapping of message type names to Go structs:</p> code.go<pre><code>// Register using sse.Register instead of huma.Register\nsse.Register(api, huma.Operation{\n\tOperationID: \"sse\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/sse\",\n\tSummary:     \"Server sent events example\",\n}, map[string]any{\n\t// Mapping of event type name to Go struct for that event.\n\t\"message\":      DefaultMessage{},\n\t\"userCreate\":   UserCreatedEvent{},\n\t\"mailRecieved\": MailReceivedEvent{},\n}, func(ctx context.Context, input *struct{}, send sse.Sender) {\n\t// Send an event every second for 10 seconds.\n\tfor x := 0; x &lt; 10; x++ {\n\t\tsend.Data(MailReceivedEvent{UserID: \"abc123\"})\n\t\ttime.Sleep(1 * time.Second)\n\t}\n})\n</code></pre> <p>Type Reuse</p> <p>Each event model must be a unique Go type. If you want to reuse Go type definitions, you can define a new type referencing another type, e.g. <code>type MySpecificEvent MyBaseEvent</code> and it will work as expected.</p>"},{"location":"features/server-sent-events-sse/#sending-data","title":"Sending Data","text":"<p>The <code>send Sender</code> passed to your SSE operation handler provides several ways of sending data to the client:</p> Method Description <code>send(Message)</code> Send an event using a full message struct <code>send.Data(any)</code> Send a message with the given data <p>Unless you need to set the message ID or retry information, the <code>send.Data(any)</code> method is preferred.</p>"},{"location":"features/server-sent-events-sse/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>sse.Register</code></li> <li><code>sse.Sender</code></li> </ul> </li> <li>External Links<ul> <li>Server Sent Events</li> </ul> </li> </ul>"},{"location":"features/test-utilities/","title":"Test Utilities","text":"<p>Huma includes a <code>humatest</code> package to make it easier to write tests for your API.</p>"},{"location":"features/test-utilities/#creating-a-test-api","title":"Creating a Test API","text":"<p>The first step is to create a test API instance. This is a router-agnostic API instance that you can register routes against and then make requests against.</p> code.go<pre><code>import (\n\t\"testing\"\n\n\t\"github.com/danielgtaylor/huma/v2/humatest\"\n)\n\nfunc TestMyAPI(t *testing.T) {\n\trouter, api := humatest.New(t)\n}\n</code></pre>"},{"location":"features/test-utilities/#registering-routes","title":"Registering Routes","text":"<p>The test API is the same as any other API, and you can register routes to it the same as you would your main API instance.</p> code.go<pre><code>func TestMyAPI(t *testing.T) {\n\trouter, api := humatest.New(t)\n\n\t// Register routes...\n\taddRoutes(api)\n}\n</code></pre>"},{"location":"features/test-utilities/#making-requests","title":"Making Requests","text":"<p>Once you have registered your routes, you can make requests against the test API instance. The <code>Get</code>, <code>Post</code>, <code>Put</code>, <code>Patch</code>, and <code>Delete</code> convenience methods are available on the test API object.</p> code.go<pre><code>func TestMyAPI(t *testing.T) {\n\trouter, api := humatest.New(t)\n\n\t// Register routes...\n\taddRoutes(api)\n\n\t// Make a GET request\n\tresp := api.Get(\"/some/path?foo=bar\")\n\n\t// Make a PUT request\n\tresp = api.Put(\"/some/path\",\n\t\t\"My-Header: abc123\",\n\t\tmap[string]any{\n\t\t\t\"author\": \"daniel\",\n\t\t\t\"rating\": 5,\n\t\t})\n}\n</code></pre> <p>The request convenience methods take a URL path followed by any number of optional arguments. If the argument is a string, it is treated as a header, if it is an <code>io.Reader</code> is is treated as the raw body, otherwise it is marshalled as JSON and used as the request body.</p>"},{"location":"features/test-utilities/#assertions","title":"Assertions","text":"<p>The request convenience methods return a <code>*httptest.ResponseRecorder</code> instance from the standard library. You can use the <code>Code</code> and <code>Body</code> fields to check the response status code and body.</p> code.go<pre><code>if resp.Code != http.StatusOK {\n\tt.Fail(\"Unexpected status code\", resp.Code)\n}\n\nif !strings.Contains(resp.Body.String(), \"some text\") {\n\tt.Fail(\"Unexpected response body\", resp.Body.String())\n}\n</code></pre> <p>Use whatever assertion library you want to make these checks. <code>stretchr/testify</code> is popular and easy to use.</p>"},{"location":"features/test-utilities/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Writing Tests</li> </ul> </li> <li>Reference<ul> <li><code>humatest</code></li> </ul> </li> <li>External Links<ul> <li>Go testing</li> </ul> </li> </ul>"},{"location":"how-to/custom-validation/","title":"Custom Validation","text":""},{"location":"how-to/custom-validation/#built-in-validators","title":"Built-in Validators","text":"<p>Huma ships with a lot of built-in validators based on JSON Schema. They support most basic use-cases and are preferred over writing your own code to do the same checks.</p> <p>Built-in validators include <code>minimum</code>, <code>maximum</code>, <code>multipleOf</code>, <code>minLength</code>, <code>maxLength</code>, <code>pattern</code>, <code>enum</code>, <code>minItems</code>, <code>maxItems</code>, etc. For example:</p> code.go<pre><code>type MyInput struct {\n\tThingID string `path:\"thing-id\" maxLength:\"12\"`\n\tTag     string `query:\"tag\" enum:\"foo,bar,baz\"`\n\tSales   uint   `query:\"sales\" maximum:\"1000\"`\n}\n</code></pre> <p>See Request Validation for all available validators. Some are added automatically, for example the <code>uint</code> above will automatically use <code>minimum:\"0\"</code> when generating the JSON Schema.</p>"},{"location":"how-to/custom-validation/#resolvers","title":"Resolvers","text":"<p>Sometimes you need to do more complex validation than what is possible with the built-in validators. For example, you might want to validate that a field value isn't some known bad value. In this case you can use a resolver. Resolvers are methods attached to inputs that are called during validation and can return errors.</p> code.go<pre><code>type MyInput struct {\n\tThingID string `path:\"thing-id\"`\n}\n\nfunc (i *MyInput) Resolve(ctx huma.Context) []error {\n\tif i.ThingID == \"bad\" {\n\t\treturn []error{&amp;huma.ErrorDetail{\n\t\t\tLocation: \"path.thing-id\",\n\t\t\tMessage:  \"Thing ID cannot be 'bad'\",\n\t\t\tValue:    i.ThingID,\n\t\t}}\n\t}\n\treturn nil\n}\n\nvar _ huma.Resolver = (*MyInput)(nil)\n</code></pre> <p>See Resolvers for more details.</p>"},{"location":"how-to/custom-validation/#example","title":"Example","text":"<p>Here's an example of using resolvers to provide additional validation for params and body fields, and how exhaustive errors are returned.</p> code.go<pre><code>// This example shows how to use resolvers to provide additional validation\n// for params and body fields, and how exhaustive errors are returned.\n//\n//\t# Example call returning seven errors\n//\trestish put :8888/count/3?count=15 -H Count:-3 count:9, nested.subCount: 6\n//\n//\t# Example success\n//\trestish put :8888/count/1 count:2, nested.subCount: 4\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `doc:\"Port to listen on.\" short:\"p\" default:\"8888\"`\n}\n\n// Create a new input type with additional validation attached to it.\ntype IntNot3 int\n\n// Resolve is called by Huma to validate the input. Prefix is the current\n// path like `path.to[3].field`, e.g. `query.count` or `body.nested.subCount`.\n// Resolvers can also be attached to structs to provide validation across\n// multiple field combinations, e.g. \"if foo is set then bar must be a\n// multiple of foo's value\". Use `prefix.With(\"bar\")` in that scenario.\nfunc (i IntNot3) Resolve(ctx huma.Context, prefix *huma.PathBuffer) []error {\n\tif i != 0 &amp;&amp; i%3 == 0 {\n\t\treturn []error{&amp;huma.ErrorDetail{\n\t\t\tLocation: prefix.String(),\n\t\t\tMessage:  \"Value cannot be a multiple of three\",\n\t\t\tValue:    i,\n\t\t}}\n\t}\n\treturn nil\n}\n\n// Ensure our resolver meets the expected interface.\nvar _ huma.ResolverWithPath = (*IntNot3)(nil)\n\nfunc main() {\n\t// Create the CLI, passing a function to be called with your custom options\n\t// after they have been parsed.\n\tcli := huma.NewCLI(func(hooks huma.Hooks, options *Options) {\n\t\trouter := chi.NewMux()\n\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register the greeting operation.\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"put-count\",\n\t\t\tSummary:     \"Put a count of things\",\n\t\t\tMethod:      http.MethodPut,\n\t\t\tPath:        \"/count/{count}\",\n\t\t}, func(ctx context.Context, input *struct {\n\t\t\tPathCount   IntNot3 `path:\"count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\n\t\t\tQueryCount  IntNot3 `query:\"count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\n\t\t\tHeaderCount IntNot3 `header:\"Count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\n\t\t\tBody        struct {\n\t\t\t\tCount  IntNot3 `json:\"count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\n\t\t\t\tNested *struct {\n\t\t\t\t\tSubCount IntNot3 `json:\"subCount\" example:\"2\" minimum:\"1\" maximum:\"10\"`\n\t\t\t\t} `json:\"nested,omitempty\"`\n\t\t\t}\n\t\t}) (*struct{}, error) {\n\t\t\tfmt.Printf(\"Got input: %+v\\n\", input)\n\t\t\treturn nil, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your router.\n\t\thooks.OnStart(func() {\n\t\t\t// Start the server\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre>"},{"location":"how-to/graceful-shutdown/","title":"Graceful Shutdown","text":""},{"location":"how-to/graceful-shutdown/#stopping-the-server","title":"Stopping the Server","text":"<p>HTTP servers should not be shut down abruptly if it can be avoided. Instead, it's better to stop accepting new requests and give any in-flight requests a chance to finish before shutting down. This is called a \"graceful shutdown\".</p> <p>This can be accomplished in Huma using the CLI <code>hooks.OnStop()</code> hook, passing a function that shuts down the server with a timeout.</p>"},{"location":"how-to/graceful-shutdown/#example","title":"Example","text":"code.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingInput represents the greeting operation request.\ntype GreetingInput struct {\n\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := huma.NewCLI(func(hooks huma.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /greeting/{name}\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-greeting\",\n\t\t\tSummary:     \"Get a greeting\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/greeting/{name}\",\n\t\t}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t\t\tresp := &amp;GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Create the HTTP server.\n\t\tserver := http.Server{\n\t\t\tAddr:    fmt.Sprintf(\":%d\", options.Port),\n\t\t\tHandler: router,\n\t\t}\n\n\t\t// Tell the CLI how to start your router.\n\t\thooks.OnStart(func() {\n\t\t\tserver.ListenAndServe()\n\t\t})\n\n\t\t// Tell the CLI how to stop your server.\n\t\thooks.OnStop(func() {\n\t\t\t// Give the server 5 seconds to gracefully shut down, then give up.\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\t\tdefer cancel()\n\t\t\tserver.Shutdown(ctx)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre> <p>Readiness Checks</p> <p>If using something like Kubernetes with readiness checks, and if the readiness route is registered on the same router as your Huma APIs, then the above code will cause the readiness check to start failing and Kubernetes will no longer route new requests to the shutting down pod as the existing connections drain.</p>"},{"location":"how-to/image-response/","title":"Image Response","text":""},{"location":"how-to/image-response/#image-response_1","title":"Image Response","text":"<p>Images or other encoded or binary responses can be returned by simply using a <code>[]byte</code> body and providing some additional information at operation registration time, such as the response body content type.</p>"},{"location":"how-to/image-response/#example","title":"Example","text":"code.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// ImageOutput represents the image operation response.\ntype ImageOutput struct {\n\tContentType string `header:\"Content-Type\"`\n\tBody        []byte\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := huma.NewCLI(func(hooks huma.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /image\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-image\",\n\t\t\tSummary:     \"Get an image\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/image\",\n\t\t\tResponses: map[string]*huma.Response{\n\t\t\t\t\"200\": {\n\t\t\t\t\tDescription: \"Image response\",\n\t\t\t\t\tContent: map[string]*huma.MediaType{\n\t\t\t\t\t\t\"image/jpeg\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, func(ctx context.Context, input *struct{}) (*ImageOutput, error) {\n\t\t\tresp := &amp;ImageOutput{}\n\t\t\tresp.ContentType = \"image/png\"\n\t\t\tresp.Body = []byte{ /* ... image bytes here ... */ }\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre>"},{"location":"how-to/migrate/","title":"Migrating From Huma V1","text":"<ol> <li>Import <code>github.com/danielgtaylor/huma/v2</code> instead of <code>github.com/danielgtaylor/huma</code>.</li> <li>Use the <code>humachi.NewV4</code> adapter as Huma v1 uses Chi v4 under the hood</li> <li>Attach your middleware to the <code>chi</code> instance.</li> <li>Replace resource &amp; operation creation with <code>huma.Register</code></li> <li>Rewrite handlers to be like <code>func(context.Context, *Input) (*Output, error)</code><ol> <li>Return errors instead of <code>ctx.WriteError(...)</code></li> <li>Return instances instead of <code>ctx.WriteModel(...)</code></li> </ol> </li> <li>Define options via a struct and use <code>huma.NewCLI</code> to wrap the service</li> </ol> <p>Note that GraphQL support from Huma v1 has been removed. Take a look at alternative tools like https://www.npmjs.com/package/openapi-to-graphql which will automatically generate a GraphQL endpoint from Huma's generated OpenAPI spec.</p>"},{"location":"how-to/oauth2-jwt/","title":"OAuth 2.0 & JWT","text":""},{"location":"how-to/oauth2-jwt/#overview","title":"Overview","text":"<p>OAuth 2.0 is a popular open standard authorization framework that enables you to verify that incoming requests are authorized to use your API.</p> <p>There are three main pieces to using OAuth 2.0 with Huma:</p> <ol> <li>Issue an access token to a client application</li> <li>Document the auth scheme and required permissions</li> <li>Authorize incoming requests</li> </ol>"},{"location":"how-to/oauth2-jwt/#issue-an-access-token","title":"Issue an Access Token","text":"<p>Huma does not provide any built-in access token issuing functionality. Instead, you can use any existing library or service to issue tokens. For simplicity's sake, we will assume you are using a third-party service for managing users and issuing tokens, like Auth0 or Okta. A simplified flow chart for OAuth2.0 authorization looks something like this:</p> <pre><code>graph LR\n\tUser --&gt;|1. Login| Auth0\n\tAuth0 --&gt;|2. Issue access token| User\n\tAuth0 -.-&gt;|Refresh JWKS| API\n\tUser ---&gt;|3. Make request| API\n\tAPI --&gt;|4. Verify access token &amp; roles| Validate\n\tValidate --&gt;|5. Accept/reject| API\n\tAPI ---&gt;|6. Success| Handler</code></pre> <p>The access token may be issued in different flavors &amp; formats, but for the remainder of this document we will assume they are JWTs.</p> <p>You will configure the third-party service to issue access token from OAuth 2.0 flows like Authorization Code or Client Credentials (among others) and will be given e.g. authorization and token URLs, which will be used later in the OpenAPI and to configure clients to fetch access tokens.</p> <p>If not using a third-party service, you will need to set up a signing authority, publish your own JWKS, and issue short-lived tokens yourself. This is outside the scope of this guide, but take a look at github.com/lestrrat-go/jwx for a library that can help.</p>"},{"location":"how-to/oauth2-jwt/#document-the-auth-scheme-in-openapi","title":"Document the Auth Scheme in OpenAPI","text":"<p>Next, you need to document the auth scheme in your OpenAPI document. This is done using the <code>SecuritySchemes</code> component. Here is an example defining an OAuth 2.0 Authorization Code flow with the URLs mentioned above and a couple of defined scopes:</p> main.go<pre><code>router := chi.NewMux()\n\nconfig := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.Components.SecuritySchemes = map[string]*huma.SecurityScheme{\n\t// Example Authorization Code flow.\n\t\"myAuth\": {\n\t\tType: \"oauth2\",\n\t\tFlows: &amp;huma.OAuthFlows{\n\t\t\tAuthorizationCode: &amp;huma.OAuthFlow{\n\t\t\t\tAuthorizationURL: \"https://example.com/oauth/authorize\",\n\t\t\t\tTokenURL:         \"https://example.com/oauth/token\",\n\t\t\t\tScopes: map[string]string{\n\t\t\t\t\t\"scope1\": \"Scope 1 description...\",\n\t\t\t\t\t\"scope2\": \"Scope 2 description...\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\n\t// Example alternative describing the use of JWTs without documenting how\n\t// they are issued or which flows might be supported. This is simpler but\n\t// tells clients less information.\n\t\"anotherAuth\": {\n\t\tType:         \"http\",\n\t\tScheme:       \"bearer\",\n\t\tBearerFormat: \"JWT\",\n\t},\n}\n\napi := humachi.New(router, config)\n</code></pre> <p>When registering your operation you can refer to the auth scheme and required scopes for that operation:</p> main.go<pre><code>huma.Register(api, huma.Operation{\n\tOperationID: \"get-greeting\",\n\tSummary:     \"Get a greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSecurity: []map[string][]string{\n\t\t{\"myAuth\": {\"scope1\"}},\n\t},\n}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// TODO: operation implementation goes here\n\treturn nil, nil\n})\n</code></pre> <p>Warning</p> <p>So far, the code above is only documenting the authorization scheme and required scopes, but does not actually authorize incoming requests. The next section will explain how to achieve the latter.</p>"},{"location":"how-to/oauth2-jwt/#authorize-incoming-requests","title":"Authorize Incoming Requests","text":"<p>Where authentication &amp; authorization happen depends on how your service is set up. In some scenarios you may have an API gateway that handles auth and forwards requests to your service. In other scenarios you may want to handle auth in your service.</p>"},{"location":"how-to/oauth2-jwt/#api-gateway-auth","title":"API Gateway Auth","text":"<p>In an API gateway scenario, you typically configure the gateway to check the <code>Authorization</code> header for a token and validate it against the JWKS URL. If the token is valid, then the gateway will forward the request to your API service. There are many such gateways (e.g. Traefik, Istio, etc) and ways of configuring them, but the general idea is similar between them:</p> <pre><code>graph LR\n\tAPIGateway[API Gateway]\n\tAuthMiddleware[Auth Middleware]\n\n\tUser --&gt;|Request| APIGateway\n\tAPIGateway --&gt; AuthMiddleware\n\tAuthMiddleware --&gt; APIGateway\n\tAPIGateway ---&gt;|Forward| API</code></pre> <p>In this case and depending on your security requirements, you may be able to skip this section since all incoming requests to your API will have already been vetted by the gateway. In this scenario, the Huma code frome the previous section serves mostly as documentation for your clients.</p>"},{"location":"how-to/oauth2-jwt/#huma-auth-middleware","title":"Huma Auth Middleware","text":"<p>Huma provides middleware functionality that can be used to authorize incoming requests within the API service itself. Here is an example that will check the <code>Authorization</code> header for a token and validate it against the JWKS URL given by your JWT issuer (e.g. Auth0/Okta). It will also check that the token has the required scopes for the operation, if any are defined.</p> main.go<pre><code>import (\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n\t\"github.com/lestrrat-go/jwx/v2/jwt\"\n)\n\n// NewJWKSet creates an auto-refreshing key set to validate JWT signatures.\nfunc NewJWKSet(jwkUrl string) jwk.Set {\n    jwkCache := jwk.NewCache(context.Background())\n\n    // register a minimum refresh interval for this URL.\n    // when not specified, defaults to Cache-Control and similar resp headers\n    err := jwkCache.Register(jwkUrl, jwk.WithMinRefreshInterval(10*time.Minute))\n    if err != nil {\n        panic(\"failed to register jwk location\")\n    }\n\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n    // fetch once on application startup\n    _, err = jwkCache.Refresh(ctx, jwkUrl)\n    if err != nil {\n        panic(\"failed to fetch on startup\")\n    }\n    // create the cached key set\n    return jwk.NewCachedSet(jwkCache, jwkUrl)\n}\n\n// NewAuthMiddleware creates a middleware that will authorize requests based on\n// the required scopes for the operation.\nfunc NewAuthMiddleware(api huma.API, jwksURL string) func(ctx huma.Context, next func(huma.Context)) {\n\tkeySet := NewJWKSet(jwksURL)\n\n\treturn func(ctx huma.Context, next func(huma.Context)) {\n\t\tvar anyOfNeededScopes []string\n\t\tisAuthorizationRequired := false\n\t\tfor _, opScheme := range ctx.Operation().Security {\n\t\t\tvar ok bool\n\t\t\tif anyOfNeededScopes, ok = opScheme[\"myAuth\"]; ok {\n\t\t\t\tisAuthorizationRequired = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !isAuthorizationRequired {\n\t\t\tnext(ctx)\n\t\t\treturn\n\t\t}\n\n\t\ttoken := strings.TrimPrefix(ctx.Header(\"Authorization\"), \"Bearer \")\n\t\tif len(token) == 0 {\n\t\t\thuma.WriteErr(api, ctx, http.StatusUnauthorized, \"Unauthorized\")\n\t\t\treturn\n\t\t}\n\n\t\t// Parse and validate the JWT.\n\t\tparsed, err := jwt.ParseString(token,\n\t\t\tjwt.WithKeySet(keySet),\n\t\t\tjwt.WithValidate(true),\n\t\t\tjwt.WithIssuer(\"my-issuer\"),\n\t\t\tjwt.WithAudience(\"my-audience\"),\n\t\t)\n\t\tif err != nil {\n\t\t\thuma.WriteErr(api, ctx, http.StatusUnauthorized, \"Unauthorized\")\n\t\t\treturn\n\t\t}\n\n\t\t// Ensure the claims required for this operation are present.\n\t\tscopes, _ := parsed.Get(\"scopes\")\n\t\tif scopes, ok := scopes.([]string); ok {\n\t\t\tfor _, scope := range scopes {\n\t\t\t\tif slices.Contains(anyOfNeededScopes, scope) {\n\t\t\t\t\tnext(ctx)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thuma.WriteErr(api, ctx, http.StatusForbidden, \"Forbidden\")\n\t}\n}\n</code></pre> <p>Lastly, when configuring your API, be sure to include this middleware:</p> main.go<pre><code>api.UseMiddleware(NewAuthMiddleware(api, \"https://example.com/.well-known/jwks.json\"))\n</code></pre>"},{"location":"how-to/oauth2-jwt/#supporting-different-token-formats","title":"Supporting different Token Formats","text":"<p>As mentioned previously, the Oauth2.0 standard does not specify the format of the access token - it merely defines how to get one. Although JWT is a very popular format, a given OAuth2.0 service or library may issue access token in different formats. The gist of what is outlined above should be adaptable to support such tokens as well, but will obviously require different methods for validation and information extraction. In the case of opaque tokens, additional interaction with an IAM server may be required inside the middleware, e.g. calling an introspection endpoint.</p>"},{"location":"how-to/oauth2-jwt/#optional-client-auto-configuration","title":"Optional: Client Auto-Configuration","text":"<p>Some clients like Restish support OpenAPI-based auth auto-configuration. This means that you can configure your client to fetch the OpenAPI document and automatically configure itself to use the correct auth mechanism. This is done by adding the <code>x-cli-config</code> extension to the OpenAPI:</p> main.go<pre><code>config.Extensions[\"x-cli-config\"] = huma.AutoConfig{ /* ... */ }\n</code></pre>"},{"location":"tutorial/cli-client/","title":"CLI Client","text":"<p>It's useful to have a terminal or command-line client for your API, so you can test it out and see how it works.</p> <p>While Huma doesn't include this functionality built-in, you can utilize Restish to quickly get a CLI up and running. Restish provides a nicer high-level interface to your API than just using <code>curl</code> or <code>httpie</code> directly, by providing commands for each operation, converting inputs into command-line arguments and options, and generating useful help documentation.</p>"},{"location":"tutorial/cli-client/#install-restish","title":"Install Restish","text":"<p>First, install Restish:</p> MacLinuxWindows <p>Install using Homebrew, Go, or download a release.</p> Terminal<pre><code># Homebrew\n$ brew tap danielgtaylor/restish\n$ brew install restish\n\n# Go (requires Go 1.18+)\n$ go install github.com/danielgtaylor/restish@latest\n</code></pre> <p>Install using Go, Homebrew for Linux, or download a release.</p> Terminal<pre><code># Go (requires Go 1.18+)\n$ go install github.com/danielgtaylor/restish@latest\n\n# Homebrew for Linux\n$ brew tap danielgtaylor/restish\n$ brew install restish\n</code></pre> <p>Install using Go or download a release.</p> Terminal<pre><code># Go (requires Go 1.18+)\n$ go install github.com/danielgtaylor/restish@latest\n</code></pre> <p>Also consider setting up shell command-line completion for Restish.</p>"},{"location":"tutorial/cli-client/#configure-your-api","title":"Configure your API","text":"<p>Next, we need to tell Restish about your API and give it a short name, which we'll call <code>tutorial</code>. Do this using the <code>api configure</code> command. This only needs to be done one time.</p>"},{"location":"tutorial/cli-client/#calling-the-api","title":"Calling the API","text":"<p>Once configured, you can call the API operations using high-level commands generated from the OpenAPI operation IDs:</p> <p>See the help commands like <code>restish tutorial --help</code> or <code>restish tutorial get-greeting --help</code> for more details. If you set up command-line completion, you can also use tab to see all available commands.</p>"},{"location":"tutorial/cli-client/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>How to install Restish</li> <li>How to configure Restish for your API</li> <li>How to call your API using Restish</li> <li>How to pass parameters and body content to Restish</li> </ul>"},{"location":"tutorial/cli-client/#dive-deeper","title":"Dive Deeper","text":"<p>Want to learn more about how Restish works and how to use it? Check these out next:</p> <ul> <li>Restish</li> <li>Restish OpenAPI 3 support</li> <li>Restish input</li> <li>A CLI for REST APIs</li> </ul>"},{"location":"tutorial/client-sdks/","title":"Client SDKs","text":"<p>Several tools can be used to create SDKs from an OpenAPI spec. Let's use the <code>oapi-codegen</code> Go code generator to create a Go SDK, and then build a client using that SDK.</p>"},{"location":"tutorial/client-sdks/#generate-the-sdk","title":"Generate the SDK","text":"<p>First, grab the OpenAPI spec. Then install and use the generator to create the SDK.</p>"},{"location":"tutorial/client-sdks/#build-the-client","title":"Build the Client","text":"<p>Next, we can use the SDK by writing a small client script.</p> client/client.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/my-user/my-api/sdk\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Initialize an SDK client.\n\tclient, _ := sdk.NewClientWithResponses(\"http://localhost:8888\")\n\n\t// Make the greeting request.\n\tgreeting, err := client.GetGreetingWithResponse(ctx, \"world\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif greeting.StatusCode() &gt; 200 {\n\t\tpanic(greeting.ApplicationproblemJSONDefault)\n\t}\n\n\t// Everything was successful, so print the message.\n\tfmt.Println(greeting.JSON200.Message)\n}\n</code></pre>"},{"location":"tutorial/client-sdks/#run-the-client","title":"Run the Client","text":"<p>Now you're ready to run the client:</p>"},{"location":"tutorial/client-sdks/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>How to install an SDK generator</li> <li>How to generate a Go SDK for your API</li> <li>How to build a client using the SDK to call the API</li> </ul>"},{"location":"tutorial/client-sdks/#dive-deeper","title":"Dive Deeper","text":"<p>Want to learn more about OpenAPI tooling like SDK generators and how to use them? Check these out next:</p> <ul> <li>SDK Generators<ul> <li><code>oapi-codegen</code></li> <li>OpenAPI Generator</li> </ul> </li> <li>OpenAPI Tool Directories<ul> <li>openapi.tools</li> <li>tools.openapis.org</li> </ul> </li> </ul>"},{"location":"tutorial/installation/","title":"Installation","text":""},{"location":"tutorial/installation/#prerequisites","title":"Prerequisites","text":"<p>Huma requires Go 1.20 or newer, so install that first. You'll also want some kind of text editor or IDE to write code and a terminal to run commands.</p>"},{"location":"tutorial/installation/#project-setup","title":"Project Setup","text":"<p>Next, open a terminal and create a new Go project, then go get the Huma dependency to it's ready to be imported:</p> <p>You should now have a directory structure like this:</p> Directory Structure<pre><code>my-api/\n  |-- go.mod\n  |-- go.sum\n</code></pre> <p>That's it! Now you are ready to build your first Huma API!</p>"},{"location":"tutorial/sending-data/","title":"Sending Data","text":"<p>Let's level up our API and accept some data from the user.</p> API Design<pre><code>Request:\nPOST /reviews\n{\n\t\"author\": \"Daniel\",\n\t\"rating\": 5,\n\t\"message\": \"Some custom review message\"\n}\n\nResponse: 201 Created\n</code></pre>"},{"location":"tutorial/sending-data/#put-review","title":"Put Review","text":"<p>Add a new operation to our API that allows users to submit reviews of our product.</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingInput represents the greeting operation request.\ntype GreetingInput struct {\n\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\n// ReviewInput represents the review operation request.\ntype ReviewInput struct {\n\tBody struct {\n\t\tAuthor  string `json:\"author\" maxLength:\"10\" doc:\"Author of the review\"`\n\t\tRating  int    `json:\"rating\" minimum:\"1\" maximum:\"5\" doc:\"Rating from 1 to 5\"`\n\t\tMessage string `json:\"message,omitempty\" maxLength:\"100\" doc:\"Review message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := huma.NewCLI(func(hooks huma.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /greeting/{name}\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-greeting\",\n\t\t\tSummary:     \"Get a greeting\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/greeting/{name}\",\n\t\t}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t\t\tresp := &amp;GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID:   \"post-review\",\n\t\t\tSummary:       \"Post a review\",\n\t\t\tMethod:        http.MethodPost,\n\t\t\tPath:          \"/reviews\",\n\t\t\tDefaultStatus: http.StatusCreated,\n\t\t}, func(ctx context.Context, i *ReviewInput) (*struct{}, error) {\n\t\t\t// TODO: save review in data store.\n\t\t\treturn nil, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre>"},{"location":"tutorial/sending-data/#calling-the-api","title":"Calling the API","text":"<p>Make a request to the API:</p> <p>You can also try sending invalid data, and see how you get exhaustive errors back from your API. Omit the <code>author</code> body field and use a rating outside the range of valid values:</p>"},{"location":"tutorial/sending-data/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>How to add a new operation to your API</li> <li>How to set a default status code for an operation</li> <li>How to accept data from the user</li> <li>How built-in validation returns errors to the user</li> <li>How to use the <code>omitempty</code> struct tag to make fields optional</li> </ul>"},{"location":"tutorial/sending-data/#dive-deeper","title":"Dive Deeper","text":"<p>Want to learn more about how sending data works? Check these out next:</p> <ul> <li>Request Inputs</li> <li>Validation</li> <li>Resolvers</li> <li>Limits</li> </ul>"},{"location":"tutorial/service-configuration/","title":"Service Configuration","text":"<p>Huma includes a basic command-line and environment variable option parser that can be used to provide runtime configuration to your service. This lets you pass in things like the port the service runs on, which environment to tag logs with, secrets and endpoints for dependencies like databases, etc.</p>"},{"location":"tutorial/service-configuration/#port-option","title":"Port Option","text":"<p>Your first API can be updated to take an optional network port parameter like this:</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingInput represents the greeting operation request.\ntype GreetingInput struct {\n\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := huma.NewCLI(func(hooks huma.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /greeting/{name}\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-greeting\",\n\t\t\tSummary:     \"Get a greeting\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/greeting/{name}\",\n\t\t}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t\t\tresp := &amp;GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre> <p>Just like requests and responses, the CLI options are defined using a custom struct with a field for each option. Once defined, all that's left is to wrap your service startup code and then run the CLI from your <code>main</code> function.</p>"},{"location":"tutorial/service-configuration/#passing-options","title":"Passing Options","text":"<p>Options can be passed explicitly as command-line arguments to the service or they can be provided by environment variables prefixed with <code>SERVICE_</code>. For example, to run the service on port 8000:</p> <pre><code># Example passing command-line args\n$ go run main.go --port=8000\n\n# Short arguments are also supported\n$ go run main.go -p 8000\n\n# Example passing by environment variables\n$ SERVICE_PORT=8000 go run main.go\n</code></pre> <p>Precedence</p> <p>If both environment variable and command-line arguments are present, then command-line arguments take priority.</p>"},{"location":"tutorial/service-configuration/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>How to add a CLI option to your service</li> <li>How to pass options via command-line arguments or environment variables</li> </ul>"},{"location":"tutorial/service-configuration/#dive-deeper","title":"Dive Deeper","text":"<p>Want to learn more about how the CLI works and how to use it? Check these out next:</p> <ul> <li>CLI intro</li> <li>CLI option types &amp; tags</li> <li>CLI custom commands</li> </ul>"},{"location":"tutorial/writing-tests/","title":"Writing Tests","text":"<p>Huma provides a number of helpers for testing your API. The most important is the <code>humatest</code> package, which allows you to run a test server and make requests against it.</p>"},{"location":"tutorial/writing-tests/#testable-code","title":"Testable Code","text":"<p>First, modify the service code to make it easier to test, by moving the operation registration code out of the <code>main</code> function:</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingInput represents the greeting operation request.\ntype GreetingInput struct {\n\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\n// ReviewInput represents the review operation request.\ntype ReviewInput struct {\n\tBody struct {\n\t\tAuthor  string `json:\"author\" maxLength:\"10\" doc:\"Author of the review\"`\n\t\tRating  int    `json:\"rating\" minimum:\"1\" maximum:\"5\" doc:\"Rating from 1 to 5\"`\n\t\tMessage string `json:\"message,omitempty\" maxLength:\"100\" doc:\"Review message\"`\n\t}\n}\n\nfunc addRoutes(api huma.API) {\n\t// Register GET /greeting/{name}\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-greeting\",\n\t\tSummary:     \"Get a greeting\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/greeting/{name}\",\n\t}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t\tresp := &amp;GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n\n\thuma.Register(api, huma.Operation{\n\t\tOperationID:   \"post-review\",\n\t\tSummary:       \"Post a review\",\n\t\tMethod:        http.MethodPost,\n\t\tPath:          \"/reviews\",\n\t\tDefaultStatus: http.StatusCreated,\n\t}, func(ctx context.Context, i *ReviewInput) (*struct{}, error) {\n\t\t// TODO: save review in data store.\n\t\treturn nil, nil\n\t})\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := huma.NewCLI(func(hooks huma.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\taddRoutes(api)\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre>"},{"location":"tutorial/writing-tests/#writing-tests_1","title":"Writing Tests","text":"<p>Use the <code>humatest</code> package to create a test API and then register your routes against it. Next, make get or post requests against it to test the various user scenarios you have to support:</p> main_test.go<pre><code>package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/danielgtaylor/huma/v2/humatest\"\n)\n\nfunc TestGetGreeting(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\n\tresp := api.Get(\"/greeting/world\")\n\tif !strings.Contains(resp.Body.String(), \"Hello, world!\") {\n\t\tt.Fatalf(\"Unexpected response: %s\", resp.Body.String())\n\t}\n}\n\nfunc TestPutReview(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\n\tresp := api.Post(\"/reviews\", map[string]any{\n\t\t\"author\": \"daniel\",\n\t\t\"rating\": 5,\n\t})\n\n\tif resp.Code != 201 {\n\t\tt.Fatalf(\"Unexpected status code: %d\", resp.Code)\n\t}\n}\n\nfunc TestPutReviewError(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\n\tresp := api.Post(\"/reviews\", map[string]any{\n\t\t\"rating\": 10,\n\t})\n\n\tif resp.Code != 422 {\n\t\tt.Fatalf(\"Unexpected status code: %d\", resp.Code)\n\t}\n}\n</code></pre> <p>Now you can run your tests!</p> Terminal<pre><code>$ go test -cover\n</code></pre>"},{"location":"tutorial/writing-tests/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>How to write tests for your API</li> <li>How to use the <code>humatest</code> package to create a test API</li> <li>How to use the <code>humatest</code> package to make requests against your API</li> <li>How to run tests and get code coverage</li> </ul>"},{"location":"tutorial/writing-tests/#dive-deeper","title":"Dive Deeper","text":"<p>Want to learn more about how testing works? Check these out next:</p> <ul> <li>Operations</li> <li>Test Utilities</li> <li><code>humatest</code> reference</li> </ul>"},{"location":"tutorial/your-first-api/","title":"Your First API","text":"<p>Let's build a simple API that greets people. We will take the person's name as a URL path parameter and respond with a JSON body containing a greeting message to that person. Here's the high-level API design:</p> API Design<pre><code>Request:\nGET /greeting/{name}\n\nResponse:\n{\n\t\"message\": \"Hello, {name}!\"\n}\n</code></pre>"},{"location":"tutorial/your-first-api/#request-input","title":"Request Input","text":"<p>Start by making a new file <code>main.go</code> and adding the greet operation's request input model:</p> main.go<pre><code>package main\n\n// GreetingInput represents the greeting operation request.\ntype GreetingInput struct {\n\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n}\n</code></pre> <p>The <code>path</code> tag tells Huma that this field should be read from the URL path, which we will use when registering the operation. The <code>maxLength</code> tag tells Huma that the name should be no longer than 30 characters.</p> <p>You should now have a directory structure that looks like:</p> Directory Structure<pre><code>my-api/\n  |-- go.mod\n  |-- go.sum\n\t|-- main.go\n</code></pre>"},{"location":"tutorial/your-first-api/#response-output","title":"Response Output","text":"<p>Next, let's add the response output model, which has a body with a <code>message</code> field for the greeting message.</p> main.go<pre><code>package main\n\n// GreetingInput represents the greeting operation request.\ntype GreetingInput struct {\n\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n</code></pre> <p>Requests and responses may define a field <code>Body</code> which will be used to marshal or unmarshal the request or response body.</p>"},{"location":"tutorial/your-first-api/#router-api","title":"Router &amp; API","text":"<p>Let's create a router, which will handle getting incoming requests to the correct operation handler, and a new API instance where we can register our operation.</p> main.go<pre><code>package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// GreetingInput represents the greeting operation request.\ntype GreetingInput struct {\n\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a new router &amp; API\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t// TODO: Register operations...\n\n\t// Start the server!\n\thttp.ListenAndServe(\"127.0.0.1:8888\", router)\n}\n</code></pre>"},{"location":"tutorial/your-first-api/#operation","title":"Operation","text":"<p>Register the operation with the Huma API instance, including how it maps to a URL and some human-friendly documentation. The handler function will take in the <code>GreetingInput</code> and return the <code>GreetingOutput</code> models we built above.</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// GreetingInput represents the greeting operation request.\ntype GreetingInput struct {\n\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a new router &amp; API\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t// Register GET /greeting/{name}\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-greeting\",\n\t\tSummary:     \"Get a greeting\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/greeting/{name}\",\n\t}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t\tresp := &amp;GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n\n\t// Start the server!\n\thttp.ListenAndServe(\"127.0.0.1:8888\", router)\n}\n</code></pre> <p>Congratulations! This is a fully functional Huma API!</p>"},{"location":"tutorial/your-first-api/#calling-the-api","title":"Calling the API","text":"<p>Let's test it out! Start the server:</p> <pre><code>$ go run .\n</code></pre> <p>In another terminal window, make a request to the API using Restish or curl:</p> RestishCurl <p></p> Terminal<pre><code># Get a greeting from the API\n$ curl http://localhost:8888/greeting/world\n</code></pre> <p>Schemas</p> <p>You can ignore the <code>Link</code> header and <code>$schema</code> field for now. These are added automatically by Huma to help clients discover information about the API, and to provide things like auto-completion and linting in editors.</p>"},{"location":"tutorial/your-first-api/#api-documentation","title":"API Documentation","text":"<p>Go to http://localhost:8888/docs to see the interactive generated documentation for the API. It should look something like this:</p> <p></p> <p>Using the panel at the top right of the documentation page you can send a request to the API and see the response.</p> <p>These docs are generated from the OpenAPI specification, which is available at http://localhost:8888/openapi.json. You can use this file to generate documentation, client libraries, commandline clients, mock servers, and more.</p>"},{"location":"tutorial/your-first-api/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>Creating Huma input and output models</li> <li>Creating a Golang REST API with Huma</li> <li>How to make requests to the API</li> <li>How to view the generated documentation</li> </ul> <p>Read on to learn how to level up your API with even more features.</p>"},{"location":"why/","title":"Why Huma?","text":""},{"location":"why/#production-ready","title":"Production Ready","text":"<p>Huma is a proven production-ready technology that has been used by large successful companies and products with millions of customers in the live streaming video space for years.</p> <p>Huma is fast to learn, easy to use, performant, and lets your organization ship APIs and related tooling like interactive documentation, CLIs and SDKs faster and with fewer bugs caused by human-error and manual processes.</p> <p>Daniel (Engineer @ Warner Bros Discovery)</p> <p>Huma has been vital for quickly building consistent, standards-compliant, well-documented APIs and generated clients &amp; SDKs for our live media streaming control plane services for configuring and running live news and sporting event channels. Teams have been able to ship faster and with fewer bugs since switching to Huma.</p>"},{"location":"why/#compatibility","title":"Compatibility","text":"<p>Huma is broadly compatible with the libraries and tools your organization is already using. It is a micro-framework meant to level up your team's API development experience without getting in your way.</p>"},{"location":"why/#huma-standards","title":"Huma \u2764\ufe0f Standards","text":"<p>Huma is built on top of open industry standards like OpenAPI, JSON Schema, and dozens of RFCs and industry best practices.</p> <p>This results in broad compatibility with other tools &amp; systems, as well as the ability to generate and automate many pieces of your workflow, including client SDK generation, documentation, and more.</p> <p>Well-known and understood standards means developers can get up to speed faster and spend less time learning new concepts. A new team can adopt Go and Huma and be productive in a matter of days.</p> <p> Config &amp; OpenAPI  JSON Schema &amp; Registry  Serialization  PATCH formats</p>"},{"location":"why/#go-is-awesome","title":"Go is Awesome","text":"<p>Huma is built on Go, which is an easy to learn, performant, and extremely powerful Top 10 programming language.</p> <p>Huma is built on top of idiomatic Go conventions and utilizes standard library concepts like <code>io.Reader</code>, <code>io.Writer</code>, <code>http.Request</code>, and more. This means that you can use many existing libraries with or alongside Huma.</p> <p>Be sure to check out the benchmarks!</p>"},{"location":"why/#routers","title":"Routers","text":"<p>Huma is router-agnostic and includes support for a handful of popular routers and their middleware your organization may already be using today:</p> <ul> <li>BunRouter</li> <li>chi</li> <li>gin</li> <li>Go 1.22+ <code>http.ServeMux</code> (experimental)</li> <li>gorilla/mux</li> <li>httprouter</li> <li>Fiber</li> </ul> <p>Huma meets you where you are and levels up your API and team.</p>"},{"location":"why/#extensibility","title":"Extensibility","text":"<p>Huma can be extended to support all your use-cases.</p>"},{"location":"why/#middleware","title":"Middleware","text":"<p>Flexible router-specific or router-agnostic middleware enables you to extend basic functionality with auth, metrics, traces, and more.</p> <p> Middleware</p>"},{"location":"why/#validation","title":"Validation","text":"<p>Huma has built-in support for validating input parameters and models using JSON Schema and/or custom Go code using resolvers, which can extend the built-in validation to do anything you want and returns exhaustive errors back to the user.</p> <p> Request Validation  Resolvers</p>"},{"location":"why/#openapi-schemas","title":"OpenAPI &amp; Schemas","text":"<p>The OpenAPI &amp; JSON Schema generation is completely customizable &amp; extensible. Huma provides low-level access and the ability to override or augment any generated specs and schemas.</p> <p> Configuration &amp; OpenAPI  JSON Schema &amp; Registry</p>"},{"location":"why/#guardrails","title":"Guardrails","text":"<p>Huma provides guardrails &amp; automation to keep your team and your services running as smoothly as possible, based on years of hard-learned lessons from many teams of engineers with a variety of skills and experience levels running and maintaining production systems at scale for millions of users.</p> <ul> <li>Service documentation that can't get out of date</li> <li>Strongly-typed models &amp; handlers with compile-time checks</li> <li>Automatic validation of input parameters and models</li> <li>Automatic serialization of responses based on client-driven content-negotiation</li> <li>Supports automatic CLI &amp; SDK generation</li> </ul> <p> Start the tutorial now</p>"},{"location":"why/benchmarks/","title":"Benchmarks","text":"<p>You should always perform your own benchmarking, as your use-case may not be identical to the use-cases of others. However, here are some general benchmarks to get you started.</p>"},{"location":"why/benchmarks/#go-performance","title":"Go Performance","text":"<p>Go is fast. When compared to Node.js and Python, Go is often much faster while using less memory and handling concurrency better. The Techempower benchmarks are a good place to start for a general comparison:</p> <p></p> <p>Notice that all the top frameworks are written in Go. Huma's performance and features will vary based on the specific router or framework used, but it is generally on par with the other top Go frameworks.</p> <p>Highlighting just a few is telling, and this ignores the improvements in memory use which likely means cheaper hardware and container costs:</p> Framework Language JSON Req/s Percentage Fortunes Req/s Percentage Chi Go 520K 100% 150K 100% Node.js Javascript 377K 73% 80K 53% FastAPI Python 168K 32% 50K 33% Django Python 73K 14% 15K 10%"},{"location":"why/benchmarks/#takeways","title":"Takeways","text":"<p>Here are a few takeaways of the above, other benchmarks, and our time with Go:</p> <ul> <li>Go (and thus Huma) is fast and low memory.</li> <li>Go is simple and can be picked up by a team quickly.<ul> <li>Its complexity is on par or less than Javascript or Python</li> </ul> </li> <li>Huma is a good choice over Node.js, FastAPI, or Django.</li> </ul>"},{"location":"why/benchmarks/#micro-benchmarks","title":"Micro Benchmarks","text":"<p>Significant performance improvements have been made since Huma v1, as shown by the following basic benchmark operation with a few input parameters, a small input body, some output headers and an output body (see <code>adapters/humachi/humachi_test.go</code>).</p> <pre><code># Huma v1\nBenchmarkHumaV1Chi-10         16285  112086 ns/op  852209 B/op  258 allocs/op\n\n# Huma v2\nBenchmarkHumaV2Chi-10        431028    2777 ns/op    1718 B/op   29 allocs/op\n\n# Chi without Huma (raw)\nBenchmarkRawChi-10           552764    2143 ns/op    2370 B/op   29 allocs/op\n</code></pre> <p>These improvements are due to a number of factors, including changes to the Huma API, precomputation of reflection data when possible, low or zero-allocation validation &amp; URL parsing, using shared buffer pools to limit garbage collector pressure, and more.</p> <p>Since you bring your own router, you are free to \"escape\" Huma by using the router directly, but as you can see above it's rarely needed with v2.</p>"},{"location":"why/what-about-design-first/","title":"What About Design First?","text":""},{"location":"why/what-about-design-first/#introduction","title":"Introduction","text":"<p>Design first is an API methodology that involves writing the API specification before writing any code. This is often presented in contrast to code first, where you write the code first and then generate the API specification from the code.</p> <pre><code>graph LR\n\tAPISpec[API Spec] --&gt; Review\n\tReview --&gt; APISpec\n\tReview --&gt; Code\n\tCode --&gt; Review2[Review]\n\tReview2 --&gt; Code\n\tReview2 --&gt; Deploy</code></pre>"},{"location":"why/what-about-design-first/#benefits","title":"Benefits","text":"<p>Design first enables you to think through the API, its use cases, and the big picture before just slapping together some code. It enables quick feedback and iteration on the API design.</p>"},{"location":"why/what-about-design-first/#false-dichotomy","title":"False Dichotomy","text":"<p>Fortunately, the \"design-first\" vs. \"code-first\" dichotomy is a false one. You can do both at the same time! In fact, Huma is designed to enable this by providing a way to write the skeleton code without any operation handler implementations which can be reviewed independently from the handlers.</p> <pre><code>graph LR\n\tHumaSkeleton[Huma Skeleton] --&gt; Review\n\tHumaSkeleton --&gt; OpenAPI[OpenAPI Spec]\n\tOpenAPI --&gt; Review\n\tReview --&gt; HumaSkeleton\n\tReview --&gt; HumaImplementation[Huma Implementation]\n\tHumaImplementation --&gt; Review2[Review]\n\tReview2 --&gt; HumaImplementation\n\tReview2 --&gt; Deploy</code></pre>"},{"location":"why/what-about-design-first/#example","title":"Example","text":"<p>Here's an example of part of the popular Pet Store API written as a skeleton in Huma, ready for review &amp; iteration either by reviewing the code or by generating the API specification and reviewing that.</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype Category struct {\n\tID   int    `json:\"id\" example:\"1\" doc:\"Category ID\"`\n\tName string `json:\"name\" example:\"Cats\" doc:\"Category name\"`\n}\n\ntype Tag struct {\n\tID   int    `json:\"id\" example:\"1\" doc:\"Tag ID\"`\n\tName string `json:\"name\" example:\"cute\" doc:\"Tag name\"`\n}\n\ntype Pet struct {\n\tID        int       `json:\"id\" example:\"1\" doc:\"Pet ID\"`\n\tCategory  *Category `json:\"category\" doc:\"Category that the pet belongs to\"`\n\tName      string    `json:\"name\" example:\"Fluffy\" doc:\"Pet name\"`\n\tPhotoURLs []string  `json:\"photoUrls\" example:\"https://example.com/fluffy.jpg\" doc:\"Photo URLs for the pet\"`\n\tTags      []Tag     `json:\"tags\" example:\"cute\" doc:\"Tags for the pet\"`\n\tStatus    string    `json:\"status\" example:\"available\" doc:\"Pet status\" enum:\"available,pending,sold\"`\n}\n\ntype PetID struct {\n\tID int `path:\"petId\" example:\"1\" doc:\"Pet ID\"`\n}\n\nfunc main() {\n\tvar api huma.API\n\n\tcli := huma.NewCLI(func(hooks huma.Hooks, options *struct{}) {\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"Pet Store\", \"1.0.0\"))\n\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"post-pet\",\n\t\t\tMethod:      \"POST\",\n\t\t\tPath:        \"/pet\",\n\t\t\tSummary:     \"Add a new pet\",\n\t\t}, func(ctx context.Context, input *struct {\n\t\t\tBody Pet\n\t\t}) (*struct{}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-pet\",\n\t\t\tMethod:      \"GET\",\n\t\t\tPath:        \"/pet/{petId}\",\n\t\t\tSummary:     \"Get a pet\",\n\t\t}, func(ctx context.Context, input *PetID) (*struct {\n\t\t\tBody Pet\n\t\t}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"find-pet-by-status\",\n\t\t\tMethod:      \"GET\",\n\t\t\tPath:        \"/pet/findByStatus\",\n\t\t\tSummary:     \"Find a pet by status\",\n\t\t}, func(ctx context.Context, input *struct {\n\t\t\tStatus string `path:\"status\" example:\"available\" doc:\"Status to filter by\" enum:\"available,pending,sold\"`\n\t\t}) (*struct {\n\t\t\tBody []Pet\n\t\t}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\t})\n\n\tcli.Root().AddCommand(&amp;cobra.Command{\n\t\tUse: \"openapi\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tb, err := api.OpenAPI().MarshalJSON()\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tfmt.Println(string(b))\n\t\t},\n\t})\n\n\tcli.Run()\n}\n</code></pre>"}]}